diff --git a/src/ui/pages/song_page.cpp b/src/ui/pages/song_page.cpp
index 5a319c5..9ec8ffe 100644
--- a/src/ui/pages/song_page.cpp
+++ b/src/ui/pages/song_page.cpp
@@ -1,4 +1,17 @@
 #include "song_page.h"
+#include "../../../scenes.h"
+#include "../../debug_log.h"
+#include "../key_normalize.h"
+#include "../ui_input.h"
+#include "../ui_common.h"
+#include "../retro_widgets.h"
+#include "../amber_widgets.h"
+#include "../retro_ui_theme.h"
+#include "../amber_ui_theme.h"
+
+namespace retro = RetroWidgets;
+namespace amber = AmberWidgets;
+using UI::showToast;
 
 #include <cctype>
 #include <cstdio>
@@ -25,6 +38,12 @@ struct SongAreaClipboard {
   std::vector<int> pattern_indices;
 };
 
+struct SongSlotClipboard {
+  bool has_song = false;
+  Song song;
+  int source_slot = 0;
+};
+
 enum class UndoActionType {
   None,
   Paste,
@@ -69,10 +88,12 @@ struct UndoHistory {
 
 SongPatternClipboard g_song_pattern_clipboard;
 SongAreaClipboard g_song_area_clipboard;
+SongSlotClipboard g_song_slot_clipboard;
 UndoHistory g_undo_history;
+
 } // namespace
 
-SongPage::SongPage(IGfx& gfx, GroovePuter& mini_acid, AudioGuard audio_guard)
+SongPage::SongPage(IGfx& gfx, MiniAcid& mini_acid, AudioGuard audio_guard)
   : gfx_(gfx),
     mini_acid_(mini_acid),
     audio_guard_(audio_guard),
@@ -108,26 +129,45 @@ int SongPage::cursorRow() const {
 int SongPage::cursorTrack() const {
   int track = cursor_track_;
   if (track < 0) track = 0;
-  if (track > 5) track = 5;
+  int maxTrack = visibleTrackCount() + 1;  // +playhead +mode
+  if (track > maxTrack) track = maxTrack;
   return track;
 }
 
-bool SongPage::cursorOnModeButton() const { return cursorTrack() == 5; }
-bool SongPage::cursorOnPlayheadLabel() const { return cursorTrack() == 4; }
+bool SongPage::cursorOnModeButton() const { return cursorTrack() == visibleTrackCount() + 1; }
+bool SongPage::cursorOnPlayheadLabel() const { return cursorTrack() == visibleTrackCount(); }
+
+int SongPage::visibleTrackCount() const { return 3; }
+
+int SongPage::maxEditableTrackColumn() const { return visibleTrackCount() - 1; }
+
+SongTrack SongPage::thirdLaneTrack() const {
+  return voice_lane_visible_ ? SongTrack::Voice : SongTrack::Drums;
+}
+
+const char* SongPage::laneShortLabel() const { return voice_lane_visible_ ? "VO" : "DR"; }
 
 void SongPage::startSelection() {
   has_selection_ = true;
   selection_start_row_ = cursor_row_;
   selection_start_track_ = cursor_track_;
+  LOG_DEBUG_UI("Selection START anchor=(r%d,c%d)", selection_start_row_, selection_start_track_);
 }
 
 void SongPage::updateSelection() {
   if (!has_selection_) {
     startSelection();
+  } else {
+    LOG_DEBUG_UI("Selection UPDATE anchor=(r%d,c%d) cursor=(r%d,c%d)",
+                 selection_start_row_, selection_start_track_, cursor_row_, cursor_track_);
   }
 }
 
 void SongPage::clearSelection() {
+  if (has_selection_) {
+    LOG_DEBUG_UI("Selection CLEAR anchor=(r%d,c%d) cursor=(r%d,c%d)",
+                 selection_start_row_, selection_start_track_, cursor_row_, cursor_track_);
+  }
   has_selection_ = false;
   if (mini_acid_.loopModeEnabled()) {
     audio_guard_([&]() { mini_acid_.setLoopMode(false); });
@@ -160,33 +200,41 @@ void SongPage::getSelectionBounds(int& min_row, int& max_row, int& min_track, in
 }
 
 void SongPage::moveCursorHorizontal(int delta, bool extend_selection) {
+  int before_row = cursor_row_;
+  int before_track = cursor_track_;
   if (extend_selection) {
     updateSelection();
-  } else {
-    clearSelection();
   }
+  // Don't clear selection on plain arrow - Cardputer fires arrow-without-Ctrl
+  // when Ctrl is released before arrow key.  Selection is cleared on action
+  // (pattern assign, ESC, etc.) instead.
   int track = cursorTrack();
   track += delta;
   if (track < 0) track = 0;
-  if (track > 5) track = 5;
+  int maxTrack = visibleTrackCount() + 1;
+  if (track > maxTrack) track = maxTrack;
   cursor_track_ = track;
   syncSongPositionToCursor();
   if (extend_selection) {
     updateLoopRangeFromSelection();
   }
+  LOG_DEBUG_INPUT("Cursor H delta=%d extend=%d (%d,%d)->(%d,%d) sel=%d",
+                  delta, (int)extend_selection,
+                  before_row, before_track, cursor_row_, cursor_track_, (int)has_selection_);
 }
 
 void SongPage::moveCursorVertical(int delta, bool extend_selection) {
   if (delta == 0) return;
+  int before_row = cursor_row_;
+  int before_track = cursor_track_;
   if (cursorOnPlayheadLabel() || cursorOnModeButton()) {
     moveCursorHorizontal(delta, extend_selection);
     return;
   }
   if (extend_selection) {
     updateSelection();
-  } else {
-    clearSelection();
   }
+  // Same as horizontal: don't clear selection on plain arrow movement
   int row = cursorRow();
   row += delta;
   row = clampCursorRow(row);
@@ -195,6 +243,9 @@ void SongPage::moveCursorVertical(int delta, bool extend_selection) {
   if (extend_selection) {
     updateLoopRangeFromSelection();
   }
+  LOG_DEBUG_INPUT("Cursor V delta=%d extend=%d (%d,%d)->(%d,%d) sel=%d",
+                  delta, (int)extend_selection,
+                  before_row, before_track, cursor_row_, cursor_track_, (int)has_selection_);
 }
 
 void SongPage::syncSongPositionToCursor() {
@@ -207,10 +258,9 @@ SongTrack SongPage::trackForColumn(int col, bool& valid) const {
   valid = true;
   if (col == 0) return SongTrack::SynthA;
   if (col == 1) return SongTrack::SynthB;
-  if (col == 2) return SongTrack::Drums;
-  if (col == 3) return SongTrack::Voice;
+  if (col == 2) return thirdLaneTrack();
   valid = false;
-  return SongTrack::Voice;
+  return SongTrack::Drums;
 }
 
 int SongPage::bankIndexForTrack(SongTrack track) const {
@@ -227,17 +277,9 @@ int SongPage::bankIndexForTrack(SongTrack track) const {
 }
 
 int SongPage::patternIndexFromKey(char key) const {
-  switch (std::tolower(static_cast<unsigned char>(key))) {
-    case 'q': return 0;
-    case 'w': return 1;
-    case 'e': return 2;
-    case 'r': return 3;
-    case 't': return 4;
-    case 'y': return 5;
-    case 'u': return 6;
-    //case 'i': return 7;
-    default: return -1;
-  }
+  // Key is already normalized (lowercase) at input source
+  // Use centralized QWERTYâ†’pattern mapping
+  return qwertyToPatternIndex(key);
 }
 
 bool SongPage::adjustSongPatternAtCursor(int delta) {
@@ -280,9 +322,55 @@ bool SongPage::adjustSongPlayhead(int delta) {
 }
 
 bool SongPage::assignPattern(int patternIdx) {
+  if (cursorOnModeButton()) return false;
+
+  // If we have a selection, fill the entire selected area
+  if (has_selection_) {
+    int min_row, max_row, min_track, max_track;
+    getSelectionBounds(min_row, max_row, min_track, max_track);
+    // Selection can include non-track columns (playhead/mode). Clamp to real track cells.
+    if (min_track < 0) min_track = 0;
+    int maxCol = maxEditableTrackColumn();
+    if (max_track > maxCol) max_track = maxCol;
+    if (min_track > max_track) {
+      LOG_WARN_UI("Selection does not include track columns: [%d..%d]", min_track, max_track);
+      return false;
+    }
+    LOG_INFO_UI("Fill selection [%d-%d] x [%d-%d] with pattern %d",
+                min_row, max_row, min_track, max_track, patternIdx);
+    int write_count = 0;
+    int changed_count = 0;
+    withAudioGuard([&]() {
+      for (int r = min_row; r <= max_row; ++r) {
+        for (int t = min_track; t <= max_track; ++t) {
+          bool valid = false;
+          SongTrack track = trackForColumn(t, valid);
+          if (!valid) continue;
+          int bankIndex = bankIndexForTrack(track);
+          int combined = songPatternFromBank(bankIndex, patternIdx);
+          int before = mini_acid_.songPatternAt(r, track);
+          mini_acid_.setSongPattern(r, track, combined);
+          int after = mini_acid_.songPatternAt(r, track);
+          ++write_count;
+          if (before != after) ++changed_count;
+          LOG_DEBUG_UI("Fill cell r=%d c=%d track=%d before=%d target=%d after=%d",
+                       r, t, (int)track, before, combined, after);
+        }
+      }
+    });
+    clearSelection();
+    char toast[48];
+    std::snprintf(toast, sizeof(toast), "Fill %d/%d -> P%d",
+                  changed_count, write_count, patternIdx + 1);
+    showToast(toast, 1200);
+    LOG_INFO_UI("Fill result: changed=%d/%d", changed_count, write_count);
+    return true;
+  }
+
+  // Single cell: assign to cursor position
   bool trackValid = false;
   SongTrack track = trackForColumn(cursorTrack(), trackValid);
-  if (!trackValid || cursorOnModeButton()) return false;
+  if (!trackValid) return false;
   int row = cursorRow();
   int bankIndex = bankIndexForTrack(track);
   int combined = songPatternFromBank(bankIndex, patternIdx);
@@ -367,21 +455,39 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
   }
 
   if (ui_event.event_type == GROOVEPUTER_APPLICATION_EVENT) {
+    auto trackFromIndex = [](int idx) {
+      switch (idx) {
+        case 0: return SongTrack::SynthA;
+        case 1: return SongTrack::SynthB;
+        case 2: return SongTrack::Drums;
+        default: return SongTrack::Voice;
+      }
+    };
+
+    bool wholeSongScope = cursorOnModeButton() || cursorOnPlayheadLabel();
     bool trackValid = false;
     SongTrack track = trackForColumn(cursorTrack(), trackValid);
-    if (!trackValid || cursorOnModeButton() || cursorOnPlayheadLabel()) {
-      return false;
-    }
+
     switch (ui_event.app_event_type) {
       case GROOVEPUTER_APP_EVENT_COPY: {
+        if (wholeSongScope) {
+          g_song_slot_clipboard.song = mini_acid_.song();
+          g_song_slot_clipboard.source_slot = mini_acid_.activeSongSlot();
+          g_song_slot_clipboard.has_song = true;
+          g_song_area_clipboard.has_area = false;
+          g_song_pattern_clipboard.has_pattern = false;
+          showToast("Song copied", 900);
+          return true;
+        }
+        if (!trackValid) return false;
         if (has_selection_) {
           // Copy selected area
           int min_row, max_row, min_track, max_track;
           getSelectionBounds(min_row, max_row, min_track, max_track);
           
-          // Only copy valid track columns (0-3)
-          if (max_track > 3) max_track = 3;
-          if (min_track > 3) return false;
+          int maxCol = maxEditableTrackColumn();
+          if (max_track > maxCol) max_track = maxCol;
+          if (min_track > maxCol) return false;
           
           int rows = max_row - min_row + 1;
           int tracks = max_track - min_track + 1;
@@ -410,14 +516,35 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
         return true;
       }
       case GROOVEPUTER_APP_EVENT_CUT: {
+        if (wholeSongScope) {
+          g_song_slot_clipboard.song = mini_acid_.song();
+          g_song_slot_clipboard.source_slot = mini_acid_.activeSongSlot();
+          g_song_slot_clipboard.has_song = true;
+          withAudioGuard([&]() {
+            for (int r = 0; r < Song::kMaxPositions; ++r) {
+              mini_acid_.clearSongPattern(r, SongTrack::SynthA);
+              mini_acid_.clearSongPattern(r, SongTrack::SynthB);
+              mini_acid_.clearSongPattern(r, SongTrack::Drums);
+              mini_acid_.clearSongPattern(r, SongTrack::Voice);
+            }
+            mini_acid_.setSongLength(1);
+            mini_acid_.setSongReverse(false);
+            if (mini_acid_.songModeEnabled() && !mini_acid_.isPlaying()) {
+              mini_acid_.setSongPosition(0);
+            }
+          });
+          showToast("Song cut", 900);
+          return true;
+        }
+        if (!trackValid) return false;
         if (has_selection_) {
           // Copy selected area first
           int min_row, max_row, min_track, max_track;
           getSelectionBounds(min_row, max_row, min_track, max_track);
           
-          // Only copy/clear valid track columns (0-3)
-          if (max_track > 3) max_track = 3;
-          if (min_track > 3) return false;
+          int maxCol = maxEditableTrackColumn();
+          if (max_track > maxCol) max_track = maxCol;
+          if (min_track > maxCol) return false;
           
           int rows = max_row - min_row + 1;
           int tracks = max_track - min_track + 1;
@@ -471,11 +598,40 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
         return true;
       }
       case GROOVEPUTER_APP_EVENT_PASTE: {
+        if (wholeSongScope) {
+          if (!g_song_slot_clipboard.has_song) return false;
+          Song pasted = g_song_slot_clipboard.song;
+          withAudioGuard([&]() {
+            for (int r = 0; r < Song::kMaxPositions; ++r) {
+              mini_acid_.clearSongPattern(r, SongTrack::SynthA);
+              mini_acid_.clearSongPattern(r, SongTrack::SynthB);
+              mini_acid_.clearSongPattern(r, SongTrack::Drums);
+              mini_acid_.clearSongPattern(r, SongTrack::Voice);
+            }
+            mini_acid_.setSongLength(pasted.length);
+            mini_acid_.setSongReverse(pasted.reverse);
+            for (int r = 0; r < pasted.length && r < Song::kMaxPositions; ++r) {
+              for (int t = 0; t < SongPosition::kTrackCount; ++t) {
+                int pattern = pasted.positions[r].patterns[t];
+                SongTrack tr = trackFromIndex(t);
+                if (pattern < 0) mini_acid_.clearSongPattern(r, tr);
+                else mini_acid_.setSongPattern(r, tr, pattern);
+              }
+            }
+            if (mini_acid_.songModeEnabled() && !mini_acid_.isPlaying()) {
+              mini_acid_.setSongPosition(0);
+            }
+          });
+          showToast("Song pasted", 900);
+          return true;
+        }
+        if (!trackValid) return false;
         if (g_song_area_clipboard.has_area) {
           // Paste area
           int start_row = cursorRow();
           int start_track = cursorTrack();
-          if (start_track > 3) return false;
+          int maxCol = maxEditableTrackColumn();
+          if (start_track > maxCol) return false;
           
           // Save old patterns for undo
           std::vector<int> old_patterns;
@@ -483,7 +639,7 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
           int max_row = start_row + g_song_area_clipboard.rows - 1;
           int min_track = start_track;
           int max_track = start_track + g_song_area_clipboard.tracks - 1;
-          if (max_track > 3) max_track = 3;
+          if (max_track > maxCol) max_track = maxCol;
           
           for (int r = min_row; r <= max_row; ++r) {
             for (int t = min_track; t <= max_track; ++t) {
@@ -504,7 +660,7 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
               for (int t = 0; t < g_song_area_clipboard.tracks; ++t) {
                 int target_row = start_row + r;
                 int target_track = start_track + t;
-                if (target_row >= Song::kMaxPositions || target_track > 3) {
+                if (target_row >= Song::kMaxPositions || target_track > maxCol) {
                   ++idx;
                   continue;
                 }
@@ -556,6 +712,7 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
         return true;
       }
       case GROOVEPUTER_APP_EVENT_UNDO: {
+        if (!trackValid) return false;
         if (g_undo_history.action_type == UndoActionType::None || g_undo_history.cells.empty()) {
           return false;
         }
@@ -590,8 +747,17 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
   }
   if (ui_event.event_type != GROOVEPUTER_KEY_DOWN) return false;
 
-  if (ui_event.alt && (ui_event.scancode == GROOVEPUTER_UP || ui_event.scancode == GROOVEPUTER_DOWN)) {
-    int delta = ui_event.scancode == GROOVEPUTER_UP ? 1 : -1;
+  // ESC or backtick: clear selection if active
+  if (ui_event.scancode == GROOVEPUTER_ESCAPE || ui_event.key == '`' || ui_event.key == '~') {
+    if (has_selection_) {
+      clearSelection();
+      return true;
+    }
+  }
+
+  int nav = UIInput::navCode(ui_event);
+  if (ui_event.alt && (nav == GROOVEPUTER_UP || nav == GROOVEPUTER_DOWN)) {
+    int delta = nav == GROOVEPUTER_UP ? 1 : -1;
     if (cursorOnPlayheadLabel()) return adjustSongPlayhead(delta);
     return adjustSongPatternAtCursor(delta);
   }
@@ -599,7 +765,7 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
   bool handled = false;
   // Cardputer keyboard may not have a practical Shift key, allow Ctrl as selection modifier too.
   bool extend_selection = ui_event.shift || ui_event.ctrl;
-  switch (ui_event.scancode) {
+  switch (nav) {
     case GROOVEPUTER_LEFT:
       moveCursorHorizontal(-1, extend_selection);
       handled = true;
@@ -624,19 +790,120 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
   char key = ui_event.key;
   if (!key) return false;
 
-  if (ui_event.ctrl && (key == 'l' || key == 'L')) {
+  // Log modifier+key combos for debugging song controls
+  if (ui_event.ctrl || ui_event.alt) {
+    LOG_DEBUG_INPUT("SongPage key=%d(0x%02X)'%c' ctrl=%d alt=%d shift=%d",
+                    (int)(unsigned char)key, (unsigned char)key,
+                    (key >= 32 && key < 127) ? key : '?',
+                    ui_event.ctrl, ui_event.alt, ui_event.shift);
+  }
+
+  // Robust Ctrl-letter handling: some keyboard paths deliver control chars (0x01..0x1A)
+  // instead of printable letters when Ctrl is held.
+  if (ui_event.ctrl) {
+    unsigned char u = static_cast<unsigned char>(key);
+    if (u >= 1 && u <= 26) {
+      key = static_cast<char>('a' + (u - 1));
+    }
+  }
+
+  bool key_j = (key == 'j') || (ui_event.scancode == GROOVEPUTER_J);
+  bool key_k = (key == 'k') || (ui_event.scancode == GROOVEPUTER_K);
+  bool key_l = (key == 'l') || (ui_event.scancode == GROOVEPUTER_L);
+  bool key_m = (key == 'm') || (ui_event.scancode == GROOVEPUTER_M);
+  bool key_n = (key == 'n') || (ui_event.scancode == GROOVEPUTER_N);
+  bool key_r = (key == 'r') || (ui_event.scancode == GROOVEPUTER_R);
+
+  if (ui_event.ctrl && key_l) {
+    LOG_INFO_UI("Toggle loop mode");
     return toggleLoopMode();
   }
 
+  // Song slot controls: Alt+J = Slot A, Alt+K = Slot B
+  if (ui_event.alt && key_j) {
+    LOG_INFO_UI("Switch to Song Slot A");
+    withAudioGuard([&]() { mini_acid_.setActiveSongSlot(0); });
+    return true;
+  }
+  if (ui_event.alt && key_k) {
+    LOG_INFO_UI("Switch to Song Slot B");
+    withAudioGuard([&]() { mini_acid_.setActiveSongSlot(1); });
+    return true;
+  }
+
+  // Song operations (Ctrl held)
+  if (ui_event.ctrl && key_r) {
+    bool wasSongMode = mini_acid_.songModeEnabled();
+    bool newReverse = !mini_acid_.isSongReverse();
+    int len = mini_acid_.songLength();
+    LOG_INFO_UI("Song reverse: %s (songMode=%d len=%d pos=%d)",
+                newReverse ? "ON" : "OFF",
+                (int)wasSongMode, len, mini_acid_.currentSongPosition());
+    withAudioGuard([&]() {
+      // Reverse direction affects song playhead logic only in Song Mode.
+      // Keep this auto-enable to avoid "REV toggles but nothing changes" confusion.
+      if (!mini_acid_.songModeEnabled()) {
+        mini_acid_.setSongMode(true);
+      }
+      mini_acid_.setSongReverse(newReverse);
+      // Apply immediately while playing in song mode so direction change is audible at once.
+      if (mini_acid_.isPlaying() && mini_acid_.songModeEnabled()) {
+        int len = mini_acid_.songLength();
+        if (len < 1) len = 1;
+        int cur = mini_acid_.currentSongPosition();
+        int next = newReverse ? (cur - 1) : (cur + 1);
+        if (next < 0) next = len - 1;
+        if (next >= len) next = 0;
+        mini_acid_.setSongPosition(next);
+      }
+    });
+    bool songModeNow = mini_acid_.songModeEnabled();
+    if (len <= 1) {
+      showToast(newReverse ? "Reverse ON (len=1)" : "Reverse OFF (len=1)", 1200);
+    } else if (!wasSongMode && songModeNow) {
+      showToast(newReverse ? "SongMode ON + Reverse ON" : "SongMode ON + Reverse OFF", 1400);
+    } else {
+      showToast(newReverse ? "Reverse: ON" : "Reverse: OFF", 1000);
+    }
+    return true;
+  }
+  if (ui_event.ctrl && key_m) {
+    LOG_INFO_UI("Merge songs (other -> active slot %d)", mini_acid_.activeSongSlot());
+    withAudioGuard([&]() { mini_acid_.mergeSongs(); });
+    showToast("Merge: done", 1000);
+    return true;
+  }
+  if (ui_event.ctrl && key_n) {
+    LOG_INFO_UI("Alternate songs (interleave slots)");
+    withAudioGuard([&]() { mini_acid_.alternateSongs(); });
+    showToast("Alternate: done", 1000);
+    return true;
+  }
+
   if (cursorOnModeButton() && (key == '\n' || key == '\r')) {
     return toggleSongMode();
   }
 
-  if (key == 'm' || key == 'M') {
+  // Song mode toggle - but NOT when Ctrl is held (avoid conflict with Ctrl+M = merge)
+  if (!ui_event.ctrl && !ui_event.alt && key_m) {
+    LOG_INFO_UI("Toggle song mode");
     return toggleSongMode();
   }
 
+  if (!ui_event.ctrl && !ui_event.alt && (key == 'v' || key == 'V' || ui_event.scancode == GROOVEPUTER_V)) {
+    voice_lane_visible_ = !voice_lane_visible_;
+    showToast(voice_lane_visible_ ? "Lane: VOICE" : "Lane: DRUMS", 1000);
+    return true;
+  }
+
+  if (!ui_event.ctrl && !ui_event.alt && (key == 'x' || key == 'X' || ui_event.scancode == GROOVEPUTER_X)) {
+    split_compare_ = !split_compare_;
+    showToast(split_compare_ ? "Split: ON" : "Split: OFF", 900);
+    return true;
+  }
+
   int patternIdx = patternIndexFromKey(key);
+  if (patternIdx < 0) patternIdx = scancodeToPatternIndex(ui_event.scancode);
   if (cursorOnModeButton() && patternIdx >= 0) return false;
   if (patternIdx >= 0) return assignPattern(patternIdx);
 
@@ -674,7 +941,8 @@ bool SongPage::handleEvent(UIEvent& ui_event) {
         // Alt+G with selection - Batch generate
         int min_row, max_row, min_track, max_track;
         getSelectionBounds(min_row, max_row, min_track, max_track);
-        if (max_track > 3) max_track = 3;
+        int maxCol = maxEditableTrackColumn();
+        if (max_track > maxCol) max_track = maxCol;
         withAudioGuard([&]() {
             for (int r = min_row; r <= max_row; ++r) {
                 for (int t = min_track; t <= max_track; ++t) {
@@ -719,6 +987,24 @@ const std::string & SongPage::getTitle() const {
 }
 
 void SongPage::draw(IGfx& gfx) {
+  switch (visual_style_) {
+    case VisualStyle::RETRO_CLASSIC:
+      drawRetroClassicStyle(gfx);
+      break;
+    case VisualStyle::AMBER:
+      drawAmberStyle(gfx);
+      break;
+    case VisualStyle::TE_GRID:
+      drawTEGridStyle(gfx);
+      break;
+    case VisualStyle::MINIMAL:
+    default:
+      drawMinimalStyle(gfx);
+      break;
+  }
+}
+
+void SongPage::drawMinimalStyle(IGfx& gfx) {
   const Rect& bounds = getBoundaries();
   int x = bounds.x;
   int y = bounds.y;
@@ -731,8 +1017,8 @@ void SongPage::draw(IGfx& gfx) {
 
   int label_h = gfx.fontHeight();
   int header_h = label_h + 4;
-  int row_h = label_h + 4;  // Reduced from +6 to +4
-  if (row_h < 8) row_h = 8;  // Minimum 8px instead of 10px
+  int row_h = label_h + 4;
+  if (row_h < 8) row_h = 8;
   int usable_h = body_h - header_h;
   if (usable_h < row_h) usable_h = row_h;
   int visible_rows = usable_h / row_h;
@@ -758,10 +1044,11 @@ void SongPage::draw(IGfx& gfx) {
   if (maxStart < 0) maxStart = 0;
   if (scroll_row_ > maxStart) scroll_row_ = maxStart;
 
+  int track_count = visibleTrackCount();
   int pos_col_w = 20;
-  int spacing = 2;  // Reduced from 3px to 2px
-  int modeBtnW = 55;  // Reduced from 70px to 55px
-  int track_col_w = (w - pos_col_w - spacing * 6 - modeBtnW) / 4;
+  int spacing = 2;
+  int modeBtnW = 55;
+  int track_col_w = (w - pos_col_w - spacing * (track_count + 2) - modeBtnW) / track_count;
   if (track_col_w < 20) track_col_w = 20;
 
   gfx.setTextColor(COLOR_LABEL);
@@ -771,11 +1058,10 @@ void SongPage::draw(IGfx& gfx) {
   gfx.setTextColor(song303Color(1));
   gfx.drawText(x + pos_col_w + spacing + track_col_w, body_y, "303B");
   gfx.setTextColor(COLOR_LABEL);
-  gfx.drawText(x + pos_col_w + spacing + track_col_w * 2, body_y, "Drums");
-  gfx.drawText(x + pos_col_w + spacing + track_col_w * 3, body_y, "Voice");
+  gfx.drawText(x + pos_col_w + spacing + track_col_w * 2, body_y, voice_lane_visible_ ? "Voice" : "Drums");
   char lenBuf[32];
   snprintf(lenBuf, sizeof(lenBuf), "PLYHD %d:%d", playhead + 1, song_len);
-  int lenX = x + pos_col_w + spacing + track_col_w * 4 + spacing + 5;
+  int lenX = x + pos_col_w + spacing + track_col_w * track_count + spacing + 5;
   int lenW = textWidth(gfx, lenBuf);
   bool playheadSelected = cursorOnPlayheadLabel();
   if (playheadSelected) {
@@ -792,111 +1078,441 @@ void SongPage::draw(IGfx& gfx) {
     gfx.setTextColor(IGfxColor::Yellow());
     gfx.drawText(loopX, body_y, loopBuf);
     gfx.setTextColor(COLOR_WHITE);
-    gfx.setTextColor(COLOR_WHITE);
   }
 
-  // Draw Generator Hint if active
   drawGeneratorHint(gfx);
 
-  int modeX = x + w - modeBtnW;
-  int modeY = body_y - 2 + 30;
-  int modeH = header_h + row_h;
-  
-  if (!mode_button_initialized_) {
-    initModeButton(modeX, modeY, modeBtnW - 2, modeH);
+  int grid_y = body_y + header_h;
+  for (int i = 0; i < visible_rows; ++i) {
+    int row_idx = scroll_row_ + i;
+    if (row_idx >= Song::kMaxPositions) break;
+    int ry = grid_y + i * row_h;
+    if (row_idx == playhead && playingSong) {
+      gfx.fillRect(x, ry, w, row_h, COLOR_PANEL);
+    }
+    char posBuf[16];
+    snprintf(posBuf, sizeof(posBuf), "%02d", row_idx + 1);
+    gfx.setTextColor(COLOR_MUTED);
+    gfx.drawText(x, ry + 2, posBuf);
+
+    for (int t = 0; t < track_count; ++t) {
+      bool valid = false;
+      SongTrack track = trackForColumn(t, valid);
+      int pattern = mini_acid_.songPatternAt(row_idx, track);
+      int tx = x + pos_col_w + spacing + t * (track_col_w + spacing);
+      bool isSelected = false;
+      if (has_selection_) {
+          int min_r, max_r, min_t, max_t;
+          getSelectionBounds(min_r, max_r, min_t, max_t);
+          isSelected = row_idx >= min_r && row_idx <= max_r && t >= min_t && t <= max_t;
+      } else {
+          isSelected = row_idx == cursor_row && t == cursor_track_;
+      }
+      
+      if (isSelected) {
+        gfx.drawRect(tx - 1, ry, track_col_w + 1, row_h, isSelected && !has_selection_ ? COLOR_STEP_SELECTED : COLOR_STEP_HILIGHT);
+      }
+      if (pattern >= 0) {
+        char patBuf[16];
+        snprintf(patBuf, sizeof(patBuf), "%d-%d", (pattern / 8) + 1, (pattern % 8) + 1);
+        gfx.setTextColor(t < 2 ? song303Color(t) : COLOR_WHITE);
+        gfx.drawText(tx + 2, ry + 2, patBuf);
+      } else {
+        gfx.setTextColor(COLOR_GRAY);
+        gfx.drawText(tx + 2, ry + 2, "---");
+      }
+    }
+    if (row_idx == playhead) {
+      gfx.setTextColor(COLOR_ACCENT);
+      gfx.drawText(x + w - 15, ry + 2, ">>");
+    }
   }
-  mode_button_container_.draw(gfx);
-  
-  bool modeSelected = cursorOnModeButton();
-  if (modeSelected) {
-    gfx.drawRect(modeX - 2, modeY - 2, modeBtnW + 2, modeH + 4, COLOR_STEP_SELECTED);
+
+  int modeX = x + pos_col_w + spacing + track_col_w * track_count + spacing + 5;
+  int modeW = w - modeX - 5;
+  int modeY = body_y + header_h;
+  int modeH = visible_rows * row_h;
+  if (!mode_button_initialized_) {
+    initModeButton(modeX, modeY, modeW, modeH);
+  } else {
+    mode_button_container_.setBoundaries(Rect(modeX, modeY, modeW, modeH));
+    bool modeSelected = cursorOnModeButton();
+    if (modeSelected) {
+      gfx.drawRect(modeX - 2, modeY - 2, modeW + 4, modeH + 4, COLOR_STEP_SELECTED);
+    }
+    mode_button_container_.draw(gfx);
   }
+}
 
-  int row_y = body_y + header_h;
-  
-  // Get selection bounds for highlighting
-  int sel_min_row, sel_max_row, sel_min_track, sel_max_track;
-  if (has_selection_) {
-    getSelectionBounds(sel_min_row, sel_max_row, sel_min_track, sel_max_track);
+void SongPage::drawTEGridStyle(IGfx& gfx) {
+  const Rect& bounds = getBoundaries();
+  int x = bounds.x;
+  int y = bounds.y;
+  int w = bounds.w;
+  int h = bounds.h;
+
+  const IGfxColor TE_BLACK = IGfxColor::Black();
+  const IGfxColor TE_WHITE = IGfxColor::White();
+  const IGfxColor TE_GRID = IGfxColor(0x353535);
+  const IGfxColor TE_ACCENT = IGfxColor(0xD8D8D8);
+  const IGfxColor TE_DIM = IGfxColor(0x8A8A8A);
+  const IGfxColor TE_ROW_A = IGfxColor(0x101010);
+  const IGfxColor TE_ROW_B = IGfxColor(0x151515);
+
+  gfx.fillRect(x, y, w, h, TE_BLACK);
+
+  int header_h = 11;
+  gfx.fillRect(x, y, w, header_h, TE_WHITE);
+  gfx.setTextColor(TE_BLACK);
+
+  int slot = mini_acid_.activeSongSlot();
+  bool reverse = mini_acid_.isSongReverse();
+  char titleBuf[40];
+  snprintf(titleBuf, sizeof(titleBuf), "SONG %c%s", 'A' + slot, reverse ? " REV" : "");
+  gfx.drawText(x + 2, y + 2, titleBuf);
+
+  char statusBuf[32];
+  int pos = mini_acid_.currentSongPosition() + 1;
+  int len = mini_acid_.songLength();
+  bool playing = mini_acid_.isPlaying();
+  bool songMode = mini_acid_.songModeEnabled();
+  snprintf(statusBuf, sizeof(statusBuf), "%s %03d/%03d %s",
+           playing ? (songMode ? ">" : "||") : "[]", pos, len, laneShortLabel());
+  int statusW = textWidth(gfx, statusBuf);
+  gfx.drawText(x + w - statusW - 2, y + 2, statusBuf);
+
+  int footer_h = 11;
+  int grid_y = y + header_h + 1;
+  int grid_h = h - header_h - footer_h - 2;
+  int cell_h = 10;
+  int row_gap = 1;
+  int visible_rows = grid_h / (cell_h + row_gap);
+  if (visible_rows < 1) visible_rows = 1;
+
+  int cursor_row = cursorRow();
+  int playhead = mini_acid_.songPlayheadPosition();
+  if (playing && songMode) {
+    int minTarget = std::min(cursor_row, playhead);
+    int maxTarget = std::max(cursor_row, playhead);
+    if (minTarget < scroll_row_) scroll_row_ = minTarget;
+    if (maxTarget >= scroll_row_ + visible_rows) scroll_row_ = maxTarget - visible_rows + 1;
+  } else {
+    if (cursor_row < scroll_row_) scroll_row_ = cursor_row;
+    if (cursor_row >= scroll_row_ + visible_rows) scroll_row_ = cursor_row - visible_rows + 1;
   }
-  
-  for (int i = 0; i < visible_rows; ++i) {
-    int row_idx = scroll_row_ + i;
-    if (row_idx >= Song::kMaxPositions) break;
-    bool isCursorRow = row_idx == cursor_row;
-    bool isPlayhead = playingSong && row_idx == playhead;
-    IGfxColor rowHighlight = isPlayhead ? IGfxColor::Magenta() : COLOR_DARKER;
-    if (isPlayhead) {
-      gfx.fillRect(x, row_y - 1, w - modeBtnW - 2, row_h, rowHighlight);
-    } else if (isCursorRow) {
-      gfx.fillRect(x, row_y - 1, w - modeBtnW - 2, row_h, COLOR_PANEL);
-    } else {
-      gfx.fillRect(x, row_y - 1, w - modeBtnW - 2, row_h, COLOR_DARKER);
+  if (scroll_row_ < 0) scroll_row_ = 0;
+
+  int min_sel_row = 0, max_sel_row = -1, min_sel_track = 0, max_sel_track = -1;
+  if (has_selection_) getSelectionBounds(min_sel_row, max_sel_row, min_sel_track, max_sel_track);
+
+  auto drawPane = [&](int paneX, int paneW, int paneSlot, bool editable) {
+    int tracks = visibleTrackCount();
+    int pos_w = 16;
+    int col_gap = 1;
+    int totalCellW = paneW - pos_w - 1 - col_gap * (tracks - 1);
+    int cell_w = totalCellW / tracks;
+    if (cell_w < 14) cell_w = 14;
+
+    gfx.setTextColor(editable ? TE_ACCENT : TE_DIM);
+    gfx.drawText(paneX + 1, grid_y, "#");
+    gfx.drawText(paneX + pos_w + 2, grid_y, "A");
+    gfx.drawText(paneX + pos_w + (cell_w + col_gap) + 2, grid_y, "B");
+    gfx.drawText(paneX + pos_w + 2 * (cell_w + col_gap) + 2, grid_y, laneShortLabel());
+    if (split_compare_) {
+      char slotBuf[10];
+      snprintf(slotBuf, sizeof(slotBuf), "S%d", paneSlot + 1);
+      int slotW = textWidth(gfx, slotBuf);
+      gfx.drawText(paneX + paneW - slotW - 1, grid_y, slotBuf);
     }
+    gfx.drawLine(paneX, grid_y + 9, paneX + paneW - 1, grid_y + 9, TE_GRID);
 
-    char posLabel[16];
-    snprintf(posLabel, sizeof(posLabel), "%d", row_idx + 1);
-    gfx.setTextColor(row_idx < song_len ? COLOR_WHITE : COLOR_LABEL);
-    gfx.drawText(x, row_y + 2, posLabel);
-    gfx.setTextColor(COLOR_WHITE);
+    int cells_y = grid_y + 11;
+    for (int i = 0; i < visible_rows; ++i) {
+      int row_idx = scroll_row_ + i;
+      if (row_idx >= Song::kMaxPositions) break;
+      int ry = cells_y + i * (cell_h + row_gap);
 
-    for (int t = 0; t < SongPosition::kTrackCount; ++t) {
-      int col_x = x + pos_col_w + spacing + t * (track_col_w + spacing);
-      bool trackValid = false;
-      SongTrack song_track = trackForColumn(t, trackValid);
-      int patternIdx = trackValid ? mini_acid_.songPatternAt(row_idx, song_track) : -1;
-      bool isSelected = isCursorRow && cursorTrack() == t;
-      bool inSelection = has_selection_ && 
-                        row_idx >= sel_min_row && row_idx <= sel_max_row &&
-                        t >= sel_min_track && t <= sel_max_track &&
-                        t <= 3; // Only valid track columns
-      
-      if (inSelection) {
-        // Draw selection highlight with a filled background
-        gfx.fillRect(col_x - 1, row_y - 2, track_col_w + 2, row_h + 2 - 1, IGfxColor(0x000080));
-        gfx.drawRect(col_x - 1, row_y - 2, track_col_w + 2, row_h + 2 - 1, IGfxColor::Cyan());
-      } else if (isSelected) {
-        IGfxColor selectedColor = COLOR_STEP_SELECTED;
-        if (song_track == SongTrack::SynthA) selectedColor = song303Color(0);
-        if (song_track == SongTrack::SynthB) selectedColor = song303Color(1);
-        gfx.drawRect(col_x - 1, row_y - 2, track_col_w + 2, row_h + 2 - 1, selectedColor);
+      gfx.fillRect(paneX, ry, paneW, cell_h, (i & 1) ? TE_ROW_B : TE_ROW_A);
+      if (row_idx == playhead && playing && songMode && paneSlot == slot) {
+        gfx.drawLine(paneX, ry + cell_h - 1, paneX + paneW - 1, ry + cell_h - 1, TE_ACCENT);
       }
-      char label[12];
-      if (patternIdx < 0) {
-        snprintf(label, sizeof(label), "--");
-        gfx.setTextColor(COLOR_LABEL);
-      } else {
-        if (song_track == SongTrack::Voice) {
-          int phraseIdx = patternIdx;
-          if (phraseIdx < 16) {
-             snprintf(label, sizeof(label), "B%d", phraseIdx + 1);
-             gfx.setTextColor(IGfxColor(0x00CED1)); // Voice color
+
+      char rowBuf[6];
+      snprintf(rowBuf, sizeof(rowBuf), "%02d", row_idx + 1);
+      gfx.setTextColor(row_idx < len ? TE_ACCENT : TE_DIM);
+      gfx.drawText(paneX + 1, ry + 1, rowBuf);
+
+      for (int t = 0; t < tracks; ++t) {
+        int tx = paneX + pos_w + t * (cell_w + col_gap);
+        bool valid = false;
+        SongTrack track = trackForColumn(t, valid);
+        int pattern = -1;
+        if (valid) {
+          pattern = (paneSlot == slot)
+              ? mini_acid_.songPatternAt(row_idx, track)
+              : mini_acid_.songPatternAtSlot(paneSlot, row_idx, track);
+        }
+
+        bool isSelected = false;
+        if (editable) {
+          if (has_selection_) {
+            isSelected = row_idx >= min_sel_row && row_idx <= max_sel_row &&
+                         t >= min_sel_track && t <= max_sel_track;
           } else {
-             snprintf(label, sizeof(label), "C%d", phraseIdx - 16 + 1);
-             gfx.setTextColor(IGfxColor(0x00FF7F)); // Custom color
+            isSelected = row_idx == cursor_row && t == cursor_track_;
           }
+        }
+
+        if (isSelected) {
+          gfx.fillRect(tx, ry, cell_w, cell_h, TE_ACCENT);
+        }
+
+        if (pattern >= 0) {
+          int bank = (pattern / 8) + 1;
+          int pslot = (pattern % 8) + 1;
+          char patBuf[10];
+          snprintf(patBuf, sizeof(patBuf), "%d-%d", bank, pslot);
+          gfx.setTextColor(isSelected ? TE_BLACK : TE_WHITE);
+          gfx.drawText(tx + 1, ry + 1, patBuf);
         } else {
-          int bankIdx = songPatternBank(patternIdx);
-          int bankPattern = songPatternIndexInBank(patternIdx);
-          if (bankIdx < 0 || bankIdx >= kBankCount || bankPattern < 0) {
-            snprintf(label, sizeof(label), "--");
-            gfx.setTextColor(COLOR_LABEL);
-          } else {
-            char bankLetter = static_cast<char>('A' + bankIdx);
-            snprintf(label, sizeof(label), "%c%d", bankLetter, bankPattern + 1);
-            if (song_track == SongTrack::SynthA) gfx.setTextColor(song303Color(0));
-            else if (song_track == SongTrack::SynthB) gfx.setTextColor(song303Color(1));
-            else gfx.setTextColor(COLOR_WHITE);
-          }
+          gfx.setTextColor(isSelected ? TE_BLACK : TE_DIM);
+          gfx.drawText(tx + 1, ry + 1, "--");
         }
       }
-      int tw = textWidth(gfx, label);
-      int tx = col_x + (track_col_w - tw) / 2;
-      gfx.drawText(tx, row_y + (row_h - label_h) / 2 - 1, label);
-      gfx.setTextColor(COLOR_WHITE);
     }
-    row_y += row_h;
+  };
+
+  if (split_compare_) {
+    int gap = 4;
+    int paneW = (w - gap) / 2;
+    int otherSlot = slot == 0 ? 1 : 0;
+    drawPane(x, paneW, slot, true);
+    drawPane(x + paneW + gap, w - paneW - gap, otherSlot, false);
+  } else {
+    drawPane(x, w, slot, true);
+  }
+
+  int footer_y = y + h - footer_h;
+  gfx.drawLine(x, footer_y - 1, x + w - 1, footer_y - 1, TE_GRID);
+  gfx.setTextColor(TE_DIM);
+  const char* cmd_text = "Q-I:PAT V:DR/VO X:SPLIT A+J/K:SLOT C+R:REV";
+  gfx.drawText(x + 2, footer_y + 2, cmd_text);
+
+  if (mini_acid_.loopModeEnabled()) {
+    int loopStart = mini_acid_.loopStartRow() + 1;
+    int loopEnd = mini_acid_.loopEndRow() + 1;
+    char loopBuf[16];
+    snprintf(loopBuf, sizeof(loopBuf), "LP:%d-%d", loopStart, loopEnd);
+    int loopW = textWidth(gfx, loopBuf);
+    gfx.fillRect(x + w - loopW - 4, footer_y, loopW + 4, footer_h, TE_WHITE);
+    gfx.setTextColor(TE_BLACK);
+    gfx.drawText(x + w - loopW - 2, footer_y + 2, loopBuf);
   }
+  drawGeneratorHint(gfx);
+}
+
+void SongPage::drawRetroClassicStyle(IGfx& gfx) {
+    const Rect& bounds = getBoundaries();
+    int x = bounds.x;
+    int y = bounds.y;
+    int w = bounds.w;
+    int h = bounds.h;
+
+    char modeBuf[32];
+    std::snprintf(modeBuf, sizeof(modeBuf), "%s", mini_acid_.songModeEnabled() ? "PLAY" : "EDIT");
+    const char* title = mini_acid_.isSongReverse() ? "SONG REV" : "SONG";
+    retro::drawHeaderBar(gfx, x, y, w, 12, title, modeBuf, mini_acid_.isPlaying(), (int)mini_acid_.bpm(), mini_acid_.currentSongPosition());
+
+    int slotX = x + 4;
+    int slotY = y + 14;
+    retro::SelectorConfig slotCfg;
+    slotCfg.x = slotX; slotCfg.y = slotY; slotCfg.w = 60; slotCfg.h = 10;
+    slotCfg.label = "SLOT";
+    slotCfg.count = 2;
+    slotCfg.selected = mini_acid_.activeSongSlot();
+    slotCfg.cursor = slotCfg.selected;
+    slotCfg.showCursor = false;
+    slotCfg.enabled = true;
+    retro::drawSelector(gfx, slotCfg);
+
+    // Draw grid headers
+    int track_count = visibleTrackCount();
+    int row_h = 10;
+    int header_y = y + 26;
+    int grid_y = header_y + 12;
+    int pos_w = 25;
+    int track_w = (w - pos_w - 4) / track_count;
+
+    gfx.setTextColor(IGfxColor(RetroTheme::TEXT_SECONDARY));
+    gfx.drawText(x + 4, header_y, "POS");
+    gfx.setTextColor(IGfxColor(RetroTheme::NEON_ORANGE));
+    gfx.drawText(x + pos_w + 4, header_y, "A");
+    gfx.setTextColor(IGfxColor(RetroTheme::NEON_MAGENTA));
+    gfx.drawText(x + pos_w + track_w + 4, header_y, "B");
+    gfx.setTextColor(IGfxColor(RetroTheme::NEON_CYAN));
+    gfx.drawText(x + pos_w + track_w * 2 + 4, header_y, voice_lane_visible_ ? "VO" : "DR");
+
+    int visible_rows = (h - grid_y - 12) / row_h;
+    if (visible_rows < 1) visible_rows = 1;
+    
+    int cursor_row = cursorRow();
+    int playhead = mini_acid_.songPlayheadPosition();
+    bool songMode = mini_acid_.songModeEnabled();
+
+    // Scroll logic
+    if (cursor_row < scroll_row_) scroll_row_ = cursor_row;
+    if (cursor_row >= scroll_row_ + visible_rows) scroll_row_ = cursor_row - visible_rows + 1;
+    if (scroll_row_ < 0) scroll_row_ = 0;
+
+    for (int i = 0; i < visible_rows; ++i) {
+        int ridx = scroll_row_ + i;
+        if (ridx >= Song::kMaxPositions) break;
+        int ry = grid_y + i * row_h;
+
+        if (ridx == playhead && mini_acid_.isPlaying() && songMode) {
+            gfx.fillRect(x, ry, w, row_h, IGfxColor(RetroTheme::BG_INSET));
+        }
+
+        char buf[16];
+        int rowLabel = ridx + 1;
+        if (rowLabel < 0) rowLabel = 0;
+        if (rowLabel > 9999) rowLabel = 9999;
+        std::snprintf(buf, sizeof(buf), "%02d", rowLabel);
+        gfx.setTextColor(IGfxColor(RetroTheme::TEXT_DIM));
+        gfx.drawText(x + 4, ry, buf);
+
+        for (int t = 0; t < track_count; ++t) {
+            int tx = x + pos_w + t * track_w + 4;
+            bool valid = false;
+            int pattern = mini_acid_.songPatternAt(ridx, trackForColumn(t, valid));
+            bool isSelected = false;
+            if (has_selection_) {
+                int min_r, max_r, min_t, max_t;
+                getSelectionBounds(min_r, max_r, min_t, max_t);
+                isSelected = ridx >= min_r && ridx <= max_r && t >= min_t && t <= max_t;
+            } else {
+                isSelected = ridx == cursor_row && t == cursor_track_;
+            }
+
+            if (isSelected) {
+                gfx.drawRect(tx - 2, ry - 1, track_w, row_h, IGfxColor(RetroTheme::SELECT_BRIGHT));
+            }
+
+            if (pattern >= 0) {
+                int bank = (pattern / 8) + 1;
+                int slot = (pattern % 8) + 1;
+                if (bank < 0) bank = 0;
+                if (bank > 999) bank = 999;
+                if (slot < 0) slot = 0;
+                if (slot > 99) slot = 99;
+                std::snprintf(buf, sizeof(buf), "%d-%d", bank, slot);
+                IGfxColor pColor = IGfxColor(RetroTheme::TEXT_PRIMARY);
+                if (t == 0) pColor = IGfxColor(RetroTheme::NEON_ORANGE);
+                else if (t == 1) pColor = IGfxColor(RetroTheme::NEON_MAGENTA);
+                else if (t == 2) pColor = IGfxColor(RetroTheme::NEON_CYAN);
+                gfx.setTextColor(pColor);
+                gfx.drawText(tx, ry, buf);
+            } else {
+                gfx.setTextColor(IGfxColor(RetroTheme::GRID_DIM));
+                gfx.drawText(tx, ry, "--");
+            }
+        }
+    }
+
+    retro::drawFooterBar(gfx, x, y + h - 12, w, 12, "A+J/K:Slot C+R:Rev C+M:Mrg C+N:Alt", "SONG");
+}
+
+void SongPage::drawAmberStyle(IGfx& gfx) {
+    const Rect& bounds = getBoundaries();
+    int x = bounds.x;
+    int y = bounds.y;
+    int w = bounds.w;
+    int h = bounds.h;
+
+    char modeBuf[32];
+    std::snprintf(modeBuf, sizeof(modeBuf), "%s", mini_acid_.songModeEnabled() ? "PLAY" : "EDIT");
+    const char* title = mini_acid_.isSongReverse() ? "SONG REV" : "SONG";
+    amber::drawHeaderBar(gfx, x, y, w, 12, title, modeBuf, mini_acid_.isPlaying(), (int)mini_acid_.bpm(), mini_acid_.currentSongPosition());
+
+    amber::SelectionBarConfig slotCfg;
+    slotCfg.x = x + 4; slotCfg.y = y + 14; slotCfg.w = 60; slotCfg.h = 10;
+    slotCfg.label = "SLOT";
+    slotCfg.count = 2;
+    slotCfg.selected = mini_acid_.activeSongSlot();
+    slotCfg.cursor = slotCfg.selected;
+    slotCfg.showCursor = false;
+    // slotCfg.enabled = true; // remove if not in struct
+    amber::drawSelectionBar(gfx, slotCfg);
+
+    int track_count = visibleTrackCount();
+    int row_h = 10;
+    int grid_y = y + 38;
+    int pos_w = 25;
+    int track_w = (w - pos_w - 4) / track_count;
+
+    int visible_rows = (h - grid_y - 12) / row_h;
+    if (visible_rows < 1) visible_rows = 1;
+
+    int cursor_row = cursorRow();
+    int playhead = mini_acid_.songPlayheadPosition();
+    bool songMode = mini_acid_.songModeEnabled();
+
+    if (cursor_row < scroll_row_) scroll_row_ = cursor_row;
+    if (cursor_row >= scroll_row_ + visible_rows) scroll_row_ = cursor_row - visible_rows + 1;
+    if (scroll_row_ < 0) scroll_row_ = 0;
+
+    for (int i = 0; i < visible_rows; ++i) {
+        int ridx = scroll_row_ + i;
+        if (ridx >= Song::kMaxPositions) break;
+        int ry = grid_y + i * row_h;
+
+        if (ridx == playhead && mini_acid_.isPlaying() && songMode) {
+            gfx.fillRect(x, ry, w, row_h, IGfxColor(AmberTheme::BG_INSET));
+        }
+
+        char buf[16];
+        int rowLabel = ridx + 1;
+        if (rowLabel < 0) rowLabel = 0;
+        if (rowLabel > 9999) rowLabel = 9999;
+        std::snprintf(buf, sizeof(buf), "%02d", rowLabel);
+        gfx.setTextColor(IGfxColor(AmberTheme::TEXT_DIM));
+        gfx.drawText(x + 4, ry, buf);
+
+        for (int t = 0; t < track_count; ++t) {
+            int tx = x + pos_w + t * track_w + 4;
+            bool valid = false;
+            int pattern = mini_acid_.songPatternAt(ridx, trackForColumn(t, valid));
+            bool isSelected = false;
+            if (has_selection_) {
+                int min_r, max_r, min_t, max_t;
+                getSelectionBounds(min_r, max_r, min_t, max_t);
+                isSelected = ridx >= min_r && ridx <= max_r && t >= min_t && t <= max_t;
+            } else {
+                isSelected = ridx == cursor_row && t == cursor_track_;
+            }
+
+            if (isSelected) {
+                gfx.drawRect(tx - 2, ry - 1, track_w, row_h, IGfxColor(AmberTheme::SELECT_BRIGHT));
+            }
+
+            if (pattern >= 0) {
+                int bank = (pattern / 8) + 1;
+                int slot = (pattern % 8) + 1;
+                if (bank < 0) bank = 0;
+                if (bank > 999) bank = 999;
+                if (slot < 0) slot = 0;
+                if (slot > 99) slot = 99;
+                std::snprintf(buf, sizeof(buf), "%d-%d", bank, slot);
+                gfx.setTextColor(IGfxColor(AmberTheme::TEXT_PRIMARY));
+                gfx.drawText(tx, ry, buf);
+            } else {
+                gfx.setTextColor(IGfxColor(AmberTheme::GRID_DIM));
+                gfx.drawText(tx, ry, "--");
+            }
+        }
+    }
+
+    amber::drawFooterBar(gfx, x, y + h - 12, w, 12, "A+J/K:Slot C+R:Rev C+M:Mrg C+N:Alt", "SONG");
 }
 
 std::unique_ptr<MultiPageHelpDialog> SongPage::getHelpDialog() {
@@ -1058,7 +1674,7 @@ void SongPage::generateEntireRow() {
     int current_bank_Drums = mini_acid_.currentDrumBankIndex();
     
     withAudioGuard([&]() {
-        for (int col = 0; col < 4; col++) {
+        for (int col = 0; col < visibleTrackCount(); col++) {
             bool valid = false;
             SongTrack track = trackForColumn(col, valid);
             if (!valid) continue;
