diff --git a/cardputer_display.cpp b/cardputer_display.cpp
index af8489c..fce51d4 100644
--- a/cardputer_display.cpp
+++ b/cardputer_display.cpp
@@ -303,6 +303,45 @@ void CardputerDisplay::fillRect(int x, int y, int w, int h, IGfxColor color) {
   }
 }
 
+void CardputerDisplay::fillCircle(int x, int y, int r, IGfxColor color) {
+  if (r < 0) return;
+  if (frame_.empty()) return;
+  uint16_t c = color.toCardputerColor();
+
+  auto drawHLine = [&](int x0, int x1, int py) {
+    if (py < 0 || py >= h_) return;
+    int startX = std::max(0, x0);
+    int endX = std::min(w_ - 1, x1);
+    for (int px = startX; px <= endX; ++px) {
+      frame_[py * w_ + px] = c;
+    }
+  };
+
+  int f = 1 - r;
+  int ddF_x = 1;
+  int ddF_y = -2 * r;
+  int xx = 0;
+  int yy = r;
+  
+  drawHLine(x - r, x + r, y);
+  
+  while (xx < yy) {
+    if (f >= 0) {
+      yy--;
+      ddF_y += 2;
+      f += ddF_y;
+    }
+    xx++;
+    ddF_x += 2;
+    f += ddF_x;
+    
+    drawHLine(x - xx, x + xx, y + yy);
+    drawHLine(x - xx, x + xx, y - yy);
+    drawHLine(x - yy, x + yy, y + xx);
+    drawHLine(x - yy, x + yy, y - xx);
+  }
+}
+
 void CardputerDisplay::setRotation(int rot) {
 #if defined(ARDUINO) && __has_include(<M5Cardputer.h>)
   M5Cardputer.Display.setRotation(rot);
diff --git a/cardputer_display.h b/cardputer_display.h
index c35fe4c..c7acfbf 100644
--- a/cardputer_display.h
+++ b/cardputer_display.h
@@ -18,6 +18,7 @@ public:
   void drawKnobFace(int cx, int cy, int radius, IGfxColor ringColor,
                     IGfxColor bgColor) override;
   void fillRect(int x, int y, int w, int h, IGfxColor color) override;
+  void fillCircle(int x, int y, int r, IGfxColor color) override;
   void drawLine(int32_t x0, int32_t y0, int32_t x1, int32_t y1) override;
   void setRotation(int rot) override;
   void setTextColor(IGfxColor color) override;
diff --git a/display.h b/display.h
index fb0296c..d7a02aa 100644
--- a/display.h
+++ b/display.h
@@ -73,6 +73,7 @@ public:
     virtual void drawKnobFace(int cx, int cy, int radius, IGfxColor ringColor,
                               IGfxColor bgColor) = 0;
     virtual void fillRect(int x, int y, int w, int h, IGfxColor color) = 0;
+    virtual void fillCircle(int x, int y, int r, IGfxColor color) = 0;
     virtual void drawLine(int32_t x0, int32_t y0, int32_t x1, int32_t y1) = 0;
     virtual void setRotation(int rot) = 0;
     virtual void setTextColor(IGfxColor color) = 0;
@@ -81,6 +82,7 @@ public:
     virtual void endWrite() = 0;
     virtual void flush() = 0; // present buffered content, if applicable
     virtual int textWidth(const char* text) const = 0;
+    virtual int measureText(const char* text) const { return textWidth(text); } // UI Kit compatibility alias
     virtual int fontHeight() const = 0;
     virtual int width() const = 0;
     virtual int height() const = 0;
diff --git a/dist/miniacid.bin b/dist/miniacid.bin
index d9f103e..9a66873 100644
Binary files a/dist/miniacid.bin and b/dist/miniacid.bin differ
diff --git a/miniacid.ino b/miniacid.ino
index d82a6b9..f174d87 100644
--- a/miniacid.ino
+++ b/miniacid.ino
@@ -34,26 +34,30 @@ static int16_t g_audioBuffer[kBlockFrames];
 TaskHandle_t g_audioTaskHandle = nullptr;
 
 // Static engine instance to avoid heap fragmentation
-static MiniAcid g_miniAcidInstance(SAMPLE_RATE, &g_sceneStorage);
-MiniAcid* g_miniAcid = nullptr;
+static MiniAcid g_miniAcidInstance(kSampleRate, &g_sceneStorage);
+MiniAcid* volatile g_miniAcid = nullptr;
 Encoder8Miniacid* g_encoder8 = nullptr;
 
 void audioTask(void *param) {
+  Serial.println("AudioTask: Starting begin()...");
   // Initialize I2S audio output
   if (!g_audioOut.begin(kSampleRate, kBlockFrames)) {
     Serial.println("[FATAL] I2S audio init failed");
     while (true) { delay(1000); }
   }
+  Serial.println("AudioTask: Loop start");
   
   while (true) {
-    if (!g_miniAcid || !g_miniAcid->isPlaying()) {
-      vTaskDelay(10 / portTICK_PERIOD_MS);
-      continue;
-    }
-
+    // Serial.println("A1"); Serial.flush();
     // Generate audio
     uint32_t start = micros();
-    g_miniAcid->generateAudioBuffer(g_audioBuffer, kBlockFrames);
+    if (g_miniAcid && g_miniAcid->isPlaying()) {
+      // Serial.println("A2"); Serial.flush();
+      g_miniAcid->generateAudioBuffer(g_audioBuffer, kBlockFrames);
+    } else {
+      // Serial.println("A3"); Serial.flush();
+      std::fill(g_audioBuffer, g_audioBuffer + kBlockFrames, 0);
+    }
     uint32_t dsp_time = micros() - start;
     
     // Check for underruns
@@ -64,20 +68,24 @@ void audioTask(void *param) {
 
     // Write to recorder if recording
     if (g_audioRecorder) {
+      // Serial.println("A4"); Serial.flush();
       g_audioRecorder->writeSamples(g_audioBuffer, kBlockFrames);
     }
     
     // Flush diagnostics periodically
     if (AudioDiagnostics::instance().isEnabled()) {
+      // Serial.println("A5"); Serial.flush();
       AudioDiagnostics::instance().flushIfReady(millis());
     }
 
     // Write to I2S (blocks until DMA accepts the buffer)
     if (!g_audioOut.writeMono16(g_audioBuffer, kBlockFrames)) {
+      // Serial.println("A6"); Serial.flush();
       // If write fails (usually because it was never initialized),
       // we MUST sleep to avoid starving lower priority tasks (like the UI/Keys!)
       vTaskDelay(10 / portTICK_PERIOD_MS);
     }
+    // Serial.println("A7"); Serial.flush();
   }
 }
 
@@ -162,6 +170,8 @@ void setup() {
 
   // Points to static instance
   g_miniAcid = &g_miniAcidInstance;
+  Serial.printf("[DEBUG] g_miniAcid addr: %p (instance: %p)\n", (void*)g_miniAcid, (void*)&g_miniAcidInstance);
+  Serial.printf("[DEBUG] MiniAcid size: %u bytes\n", (unsigned)sizeof(MiniAcid));
   
   screenLog("4. Engine Static OK");
   
@@ -193,8 +203,9 @@ void setup() {
   }
 
   
-  screenLog("7. UI Setup...");
+  Serial.println("7a. UI Instance Created");
   g_miniDisplay = new MiniAcidDisplay(g_display, *g_miniAcid);
+  Serial.println("7b. UI setAudioGuard");
   
   // Set audio guard to protect audio task from concurrent access
   g_miniDisplay->setAudioGuard([](const std::function<void()>& fn) {
@@ -203,22 +214,28 @@ void setup() {
     fn();
   });
   
+  Serial.println("7c. UI setAudioRecorder");
   // Initialize audio recorder (done after other initialization to avoid boot issues)
-  g_audioRecorder = new CardputerAudioRecorder();
-  g_miniDisplay->setAudioRecorder(g_audioRecorder);
+  // DISABLING FOR CRASH DEBUGGING
+  // g_audioRecorder = new CardputerAudioRecorder();
+  // g_miniDisplay->setAudioRecorder(g_audioRecorder);
 
+  Serial.println("8. Creating AudioTask...");
   xTaskCreatePinnedToCore(audioTask, "AudioTask",
-                          4096, // stack
+                          8192, // stack
                           nullptr,
                           3, // priority
                           &g_audioTaskHandle,
                           1 // core
   );
 
+  Serial.println("9. Final Init...");
   g_encoder8->initialize();
   LedManager::instance().init();
 
+  Serial.println("10. First drawUI...");
   drawUI();
+  Serial.println("setup() complete");
 }
 
 
diff --git a/platform_sdl/Makefile b/platform_sdl/Makefile
index 7024b78..f64dd5b 100644
--- a/platform_sdl/Makefile
+++ b/platform_sdl/Makefile
@@ -22,7 +22,7 @@ ifeq ($(strip $(SDL_GFX_CFLAGS)),)
 endif
 
 TARGET := miniacid
-SOURCES := ../src/dsp/filter.cpp ../src/dsp/mini_tb303.cpp ../src/dsp/mini_drumvoices.cpp ../src/dsp/tube_distortion.cpp ../src/dsp/miniacid_engine.cpp ../src/dsp/mode_manager.cpp ../src/ui/miniacid_display.cpp ../src/ui/cassette_skin.cpp ../src/ui/pages/help_page.cpp ../src/ui/pages/help_dialog.cpp ../src/ui/pages/tb303_params_page.cpp ../src/ui/pages/waveform_page.cpp ../src/ui/pages/pattern_edit_page.cpp ../src/ui/pages/drum_sequencer_page.cpp ../src/ui/pages/song_page.cpp ../src/ui/pages/project_page.cpp ../src/ui/pages/mode_page.cpp ../src/ui/components/pattern_selection_bar.cpp ../src/ui/components/bank_selection_bar.cpp ../src/ui/components/label_option.cpp ../src/audio/desktop_audio_recorder.cpp ../src/audio/wasm_audio_recorder.cpp ../src/sampler/sample_loader.cpp ../src/sampler/ram_sample_store.cpp ../src/sampler/sample_index.cpp ../src/sampler/sampler_voice.cpp ../src/sampler/sampler_pool.cpp ../src/sampler/drum_sampler_track.cpp ../src/dsp/tape_fx.cpp ../src/dsp/tape_looper.cpp ../src/ui/pages/sampler_page.cpp ../src/ui/pages/tape_page.cpp ../cardputer_display.cpp ../scenes.cpp ../json_evented.cpp sdl_main.cpp sdl_display.cpp scene_storage_sdl.cpp ../src/ui/ui_core.cpp
+SOURCES := ../src/dsp/filter.cpp ../src/dsp/mini_tb303.cpp ../src/dsp/mini_drumvoices.cpp ../src/dsp/tube_distortion.cpp ../src/dsp/miniacid_engine.cpp ../src/dsp/mode_manager.cpp ../src/ui/miniacid_display.cpp ../src/ui/cassette_skin.cpp ../src/ui/pages/help_page.cpp ../src/ui/pages/help_dialog.cpp ../src/ui/pages/tb303_params_page.cpp ../src/ui/pages/waveform_page.cpp ../src/ui/pages/pattern_edit_page.cpp ../src/ui/pages/drum_sequencer_page.cpp ../src/ui/pages/song_page.cpp ../src/ui/pages/project_page.cpp ../src/ui/pages/mode_page.cpp ../src/ui/components/pattern_selection_bar.cpp ../src/ui/components/bank_selection_bar.cpp ../src/ui/components/label_option.cpp ../src/ui/led_manager.cpp ../src/audio/desktop_audio_recorder.cpp ../src/audio/wasm_audio_recorder.cpp ../src/sampler/sample_loader.cpp ../src/sampler/ram_sample_store.cpp ../src/sampler/sample_index.cpp ../src/sampler/sampler_voice.cpp ../src/sampler/sampler_pool.cpp ../src/sampler/drum_sampler_track.cpp ../src/dsp/tape_fx.cpp ../src/dsp/tape_looper.cpp ../src/ui/pages/sampler_page.cpp ../src/ui/pages/tape_page.cpp ../cardputer_display.cpp ../scenes.cpp ../json_evented.cpp sdl_main.cpp sdl_display.cpp scene_storage_sdl.cpp ../src/ui/ui_core.cpp
 
 ROOT := $(abspath ..)
 DOCKER ?= docker
diff --git a/platform_sdl/sdl_display.cpp b/platform_sdl/sdl_display.cpp
index 1ca4723..03258dd 100644
--- a/platform_sdl/sdl_display.cpp
+++ b/platform_sdl/sdl_display.cpp
@@ -280,6 +280,40 @@ void SDLDisplay::drawRect(int x, int y, int w, int h, IGfxColor color) {
   SDL_RenderDrawRect(renderer_, &r);
 }
 
+void SDLDisplay::fillCircle(int x, int y, int radius, IGfxColor color) {
+  if (!renderer_ || radius <= 0) return;
+  setDrawColor(renderer_, color);
+
+  // Midpoint circle algorithm for filled circle
+  // We draw horizontal lines between the points on the circumference
+  int cx = x;
+  int cy = y;
+  int xo = radius;
+  int yo = 0;
+  int err = 0;
+
+  auto drawHLine = [&](int x1, int x2, int y) {
+      if (x1 > x2) std::swap(x1, x2);
+      SDL_RenderDrawLine(renderer_, x1, y, x2, y);
+  };
+
+  while (xo >= yo) {
+      drawHLine(cx - xo, cx + xo, cy + yo);
+      drawHLine(cx - xo, cx + xo, cy - yo);
+      drawHLine(cx - yo, cx + yo, cy + xo);
+      drawHLine(cx - yo, cx + yo, cy - xo);
+
+      if (err <= 0) {
+          yo += 1;
+          err += 2 * yo + 1;
+      }
+      if (err > 0) {
+          xo -= 1;
+          err -= 2 * xo + 1;
+      }
+  }
+}
+
 void SDLDisplay::drawCircle(int x, int y, int r, IGfxColor color) {
   if (!renderer_) return;
   uint32_t packed = color.color24();
diff --git a/platform_sdl/sdl_display.h b/platform_sdl/sdl_display.h
index 103ba6e..97e6ed6 100644
--- a/platform_sdl/sdl_display.h
+++ b/platform_sdl/sdl_display.h
@@ -22,6 +22,7 @@ public:
   void fillRect(int x, int y, int w, int h, IGfxColor color) override;
   void drawRect(int x, int y, int w, int h, IGfxColor color) override;
   void drawCircle(int x, int y, int r, IGfxColor color) override;
+  void fillCircle(int x, int y, int r, IGfxColor color) override;
   void drawKnobFace(int cx, int cy, int radius, IGfxColor ringColor,
                     IGfxColor bgColor) override;
   void drawLine(int32_t x0, int32_t y0, int32_t x1, int32_t y1) override;
diff --git a/platform_sdl/sdl_main.cpp b/platform_sdl/sdl_main.cpp
index 7238180..c5562bf 100644
--- a/platform_sdl/sdl_main.cpp
+++ b/platform_sdl/sdl_main.cpp
@@ -15,6 +15,11 @@
 #include "../src/audio/audio_config.h"
 #include "scene_storage_sdl.h"
 #include "../src/sampler/ram_sample_store.h"
+#include "arduino_compat.h"
+
+// Define Serial instance for SDL build
+SerialMock Serial;
+
 #ifndef __EMSCRIPTEN__
 #include "../src/audio/desktop_audio_recorder.h"
 #else
diff --git a/src/audio/audio_diagnostics.h b/src/audio/audio_diagnostics.h
index ed0fe07..a982423 100644
--- a/src/audio/audio_diagnostics.h
+++ b/src/audio/audio_diagnostics.h
@@ -39,7 +39,7 @@ public:
     float absPost = fabsf(postLimiter);
     if (absPost > diag_.peakPost) diag_.peakPost = absPost;
     
-    if (!isfinite(preLimiter) || !isfinite(postLimiter)) {
+    if (!std::isfinite(preLimiter) || !std::isfinite(postLimiter)) {
       diag_.nanCount++;
     }
     
diff --git a/src/dsp/advanced_pattern_generator.h b/src/dsp/advanced_pattern_generator.h
index a670b7f..0cdaf81 100644
--- a/src/dsp/advanced_pattern_generator.h
+++ b/src/dsp/advanced_pattern_generator.h
@@ -3,7 +3,11 @@
 #include <algorithm>
 #include <cmath>
 #include "../../scenes.h" // For pattern structs
-#include "Arduino.h"      // For random() if needed, or standard lib
+#if defined(ARDUINO)
+#include <Arduino.h>
+#else
+#include "../../platform_sdl/arduino_compat.h"
+#endif
 
 
 class AdvancedPatternGenerator {
diff --git a/src/dsp/miniacid_engine.cpp b/src/dsp/miniacid_engine.cpp
index f6ad476..52015fe 100644
--- a/src/dsp/miniacid_engine.cpp
+++ b/src/dsp/miniacid_engine.cpp
@@ -1,6 +1,10 @@
 #include "miniacid_engine.h"
 
+#if defined(ARDUINO)
 #include <Arduino.h>
+#else
+#include "../../platform_sdl/arduino_compat.h"
+#endif
 #include <algorithm>
 #include <cmath>
 #include <cctype>
@@ -206,10 +210,13 @@ MiniAcid::MiniAcid(float sampleRate, SceneStorage* sceneStorage)
   : voice303(sampleRate),
     voice3032(sampleRate),
     drums(std::make_unique<TR808DrumSynthVoice>(sampleRate)),
-    // drums(std::make_unique<TR909DrumSynthVoice>(sampleRate)),
     sampleRateValue(sampleRate),
     drumEngineName_("808"),
     sceneStorage_(sceneStorage),
+    samplerOutBuffer(std::make_unique<float[]>(AUDIO_BUFFER_SAMPLES)),
+    samplerTrack(std::make_unique<DrumSamplerTrack>()),
+    tapeFX(std::make_unique<TapeFX>()),
+    tapeLooper(std::make_unique<TapeLooper>()),
     playing(false),
     mute303(false),
     mute303_2(false),
@@ -242,7 +249,6 @@ MiniAcid::MiniAcid(float sampleRate, SceneStorage* sceneStorage)
     distortion3032(),
     currentTimingOffset_(0) {
   if (sampleRateValue <= 0.0f) sampleRateValue = 44100.0f;
-  // Don't call reset() here, drums are not allocated yet!
 }
 
 
@@ -259,7 +265,7 @@ void MiniAcid::init() {
   if (hasPsram) {
     LOG_PRINTLN("  - MiniAcid::init: PSRAM mode (high performance)");
     // PSRAM: High-performance mode (44.1kHz = ~176KB per second float)
-    tapeLooper.init(8);           // 8s looper (~1.4MB)
+    if (tapeLooper) tapeLooper->init(8);           // 8s looper (~1.4MB)
     if (sampleStore) sampleStore->setPoolSize(2 * 1024 * 1024); // 2MB pool
     delay303.init(1.0f);
     delay3032.init(1.0f);
@@ -268,7 +274,7 @@ void MiniAcid::init() {
     // DRAM: Constrained mode (44.1kHz is expensive!)
     // 0.25s delay = 44KB -> Two of them = 88KB. Feasible.
     // Tape Looper: 0.25s = 44KB. 
-    tapeLooper.init(0.25f); 
+    if (tapeLooper) tapeLooper->init(0.25f); 
     if (sampleStore) sampleStore->setPoolSize(32 * 1024); // 32KB sampler pool
     delay303.init(0.25f);
     delay3032.init(0.25f);
@@ -297,8 +303,11 @@ void MiniAcid::init() {
     setDrumEngine("909"); 
   }
 
+  LOG_PRINTLN("  - MiniAcid::init: reset()...");
   reset();
+  LOG_PRINTLN("  - MiniAcid::init: applySceneStateFromManager()...");
   applySceneStateFromManager();
+  LOG_PRINTLN("  - MiniAcid::init: Done");
 }
 
 void MiniAcid::reset() {
@@ -1177,47 +1186,50 @@ void MiniAcid::advanceStep() {
 
   if (kick.steps[currentStepIndex].hit && !muteKick && drumsActive) {
     drums->triggerKick(stepAccent, kick.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(0, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(0, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumKick, sceneManager_.currentScene().led);
   }
   if (snare.steps[currentStepIndex].hit && !muteSnare && drumsActive) {
     drums->triggerSnare(stepAccent, snare.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(1, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(1, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumSnare, sceneManager_.currentScene().led);
   }
   if (hat.steps[currentStepIndex].hit && !muteHat && drumsActive) {
     drums->triggerHat(stepAccent, hat.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(2, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(2, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumHatC, sceneManager_.currentScene().led);
   }
   if (openHat.steps[currentStepIndex].hit && !muteOpenHat && drumsActive) {
     drums->triggerOpenHat(stepAccent, openHat.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(3, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(3, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumHatO, sceneManager_.currentScene().led);
   }
   if (midTom.steps[currentStepIndex].hit && !muteMidTom && drumsActive) {
     drums->triggerMidTom(stepAccent, midTom.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(4, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(4, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumTomM, sceneManager_.currentScene().led);
   }
   if (highTom.steps[currentStepIndex].hit && !muteHighTom && drumsActive) {
     drums->triggerHighTom(stepAccent, highTom.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(5, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(5, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumTomH, sceneManager_.currentScene().led);
   }
   if (rim.steps[currentStepIndex].hit && !muteRim && drumsActive) {
     drums->triggerRim(stepAccent, rim.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(6, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(6, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumRim, sceneManager_.currentScene().led);
   }
   if (clap.steps[currentStepIndex].hit && !muteClap && drumsActive) {
     drums->triggerClap(stepAccent, clap.steps[currentStepIndex].velocity);
-    if (sampleStore) samplerTrack.triggerPad(7, stepAccent ? 1.0f : 0.6f, *sampleStore);
+    if (sampleStore) samplerTrack->triggerPad(7, stepAccent ? 1.0f : 0.6f, *sampleStore);
     LedManager::instance().onVoiceTriggered(VoiceId::DrumClap, sceneManager_.currentScene().led);
   }
 }
 
 void MiniAcid::generateAudioBuffer(int16_t *buffer, size_t numSamples) {
+  static int count = 0;
+  if (count++ % 100 == 0) Serial.printf("GAB: this=%p buf=%p\n", (void*)this, (void*)buffer);
+  
   if (!buffer || numSamples == 0) {
     return;
   }
@@ -1241,18 +1253,18 @@ void MiniAcid::generateAudioBuffer(int16_t *buffer, size_t numSamples) {
   // Update tape FX parameters ONCE per buffer (not per sample!)
   // Uses dirty flag internally to skip expensive recalculations when unchanged
   const TapeState& tapeState = sceneManager_.currentScene().tape;
-  tapeFX.applyMacro(tapeState.macro);
-  tapeFX.applyMinimalParams(tapeState.space, tapeState.movement, tapeState.groove);
-  tapeLooper.setMode(tapeState.mode);
-  tapeLooper.setSpeed(tapeState.speed);
-  tapeLooper.setVolume(tapeState.looperVolume);
+  tapeFX->applyMacro(tapeState.macro);
+  tapeFX->applyMinimalParams(tapeState.space, tapeState.movement, tapeState.groove);
+  tapeLooper->setMode(tapeState.mode);
+  tapeLooper->setSpeed(tapeState.speed);
+  tapeLooper->setVolume(tapeState.looperVolume);
 
   // Optimization: render sampler track in a block once per buffer
   // Note: this has a max 1-buffer jitter for triggers (standard for blocks)
   bool hasSampleStore = (sampleStore != nullptr);
   if (hasSampleStore) {
-    std::fill(samplerOutBuffer, samplerOutBuffer + numSamples, 0.0f);
-    samplerTrack.process(samplerOutBuffer, numSamples, *sampleStore);
+    std::fill(samplerOutBuffer.get(), samplerOutBuffer.get() + numSamples, 0.0f);
+    samplerTrack->process(samplerOutBuffer.get(), numSamples, *sampleStore);
   }
 
   for (size_t i = 0; i < numSamples; ++i) {
@@ -1362,15 +1374,15 @@ void MiniAcid::generateAudioBuffer(int16_t *buffer, size_t numSamples) {
     }
 
     // Process through Looper (Tape layer 1) - only when not stopped
-    if (tapeLooper.mode() != TapeMode::Stop) {
+    if (tapeLooper->mode() != TapeMode::Stop) {
       float loopSample = 0.0f;
-      tapeLooper.process(sample, &loopSample);
+      tapeLooper->process(sample, &loopSample);
       sample += loopSample;
     }
 
     // Process through Tape FX (Tape layer 2: Wow/Flutter/Saturation/Age/Tone/Crush)
     if (tapeState.fxEnabled) {
-      sample = tapeFX.process(sample);
+      sample = tapeFX->process(sample);
     }
 
     // --- MASTER OUT (Clean Hi-Fi Chain) ---
@@ -1638,7 +1650,7 @@ void MiniAcid::applySceneStateFromManager() {
   // Sync Sampler
   for (int i = 0; i < 16; ++i) {
     const auto& s = sceneManager_.currentScene().samplerPads[i];
-    auto& p = samplerTrack.pad(i);
+    auto& p = samplerTrack->pad(i);
     p.id.value = s.sampleId;
     p.volume = s.volume;
     p.pitch = s.pitch;
@@ -1653,17 +1665,22 @@ void MiniAcid::applySceneStateFromManager() {
   LOG_PRINTLN("  - MiniAcid::applySceneStateFromManager: syncing Tape...");
   // Sync Tape - uses dirty flag so this is safe to call
   const auto& t = sceneManager_.currentScene().tape;
-  tapeFX.applyMacro(t.macro);
-  tapeLooper.setMode(t.mode);
-  tapeLooper.setSpeed(t.speed);
-  tapeLooper.setVolume(t.looperVolume);
+  if (tapeFX) tapeFX->applyMacro(t.macro);
+  if (tapeLooper) {
+    tapeLooper->setMode(t.mode);
+    tapeLooper->setSpeed(t.speed);
+    tapeLooper->setVolume(t.looperVolume);
+  }
   
+  LOG_PRINTLN("  - MiniAcid::applySceneStateFromManager: applyGenreTimbre...");
   // 1. Enforce Genre Timbre BASE (overwrites scene params to ensure genre identity)
   genreManager_.applyGenreTimbre(*this);
   
+  LOG_PRINTLN("  - MiniAcid::applySceneStateFromManager: resetTextureBiasTracking...");
   // 2. Reset bias tracking so subsequent texture application is fresh delta from new base
   genreManager_.resetTextureBiasTracking();
   
+  LOG_PRINTLN("  - MiniAcid::applySceneStateFromManager: applyTexture...");
   // 3. Apply texture (delta bias + FX)
   genreManager_.applyTexture(*this);
   
diff --git a/src/dsp/miniacid_engine.h b/src/dsp/miniacid_engine.h
index 0447e14..e17e5fe 100644
--- a/src/dsp/miniacid_engine.h
+++ b/src/dsp/miniacid_engine.h
@@ -187,6 +187,11 @@ public:
   GrooveboxMode grooveboxMode() const;
   void toggleGrooveboxMode();
 
+  // UI Convenience
+  int currentScene() const { return current303BankIndex(0); }
+  bool isRecording() const { return sceneManager().currentScene().tape.mode == TapeMode::Rec; }
+  float swing() const { return genreManager().getGenerativeParams().swingAmount; }
+
   GrooveboxModeManager& modeManager() { return modeManager_; }
   const GrooveboxModeManager& modeManager() const { return modeManager_; }
   
@@ -335,11 +340,11 @@ public:
   // Public access to stats and sample bank for now
   PerfStats perfStats;
   ISampleStore* sampleStore = nullptr;
-  float samplerOutBuffer[AUDIO_BUFFER_SAMPLES];
+  std::unique_ptr<float[]> samplerOutBuffer;
   SampleIndex sampleIndex;
-  DrumSamplerTrack samplerTrack;
-  TapeFX tapeFX;
-  TapeLooper tapeLooper;
+  std::unique_ptr<DrumSamplerTrack> samplerTrack;
+  std::unique_ptr<TapeFX> tapeFX;
+  std::unique_ptr<TapeLooper> tapeLooper;
   
   // Scene manager accessor for UI tape state
   SceneManager& sceneManager() { return sceneManager_; }
diff --git a/src/ui/led_manager.cpp b/src/ui/led_manager.cpp
index fe0f5a7..96c3a99 100644
--- a/src/ui/led_manager.cpp
+++ b/src/ui/led_manager.cpp
@@ -1,6 +1,11 @@
 #include "led_manager.h"
+
+#if defined(ARDUINO)
 #include <Arduino.h>
 #include <M5Cardputer.h>
+#else
+#include "../../platform_sdl/arduino_compat.h"
+#endif
 
 LedManager& LedManager::instance() {
     static LedManager inst;
diff --git a/src/ui/pages/drum_sequencer_page.cpp b/src/ui/pages/drum_sequencer_page.cpp
index 4755889..6e8a195 100644
--- a/src/ui/pages/drum_sequencer_page.cpp
+++ b/src/ui/pages/drum_sequencer_page.cpp
@@ -3,6 +3,7 @@
 #include <cctype>
 #include <utility>
 
+#include "../ui_input.h"
 #include "../help_dialog_frames.h"
 #include "../components/bank_selection_bar.h"
 #include "../components/label_option.h"
@@ -543,8 +544,17 @@ bool DrumSequencerMainPage::handleEvent(UIEvent& ui_event) {
     }
   }
   if (ui_event.event_type != MINIACID_KEY_DOWN) return false;
+
+  // Let parent handle global navigation ([ ] page jumps, help, back, etc.)
+  // IMPORTANT: we do NOT want to steal them here.
+  if (UIInput::isGlobalNav(ui_event)) return false;
+
   bool handled = false;
-  switch (ui_event.scancode) {
+  
+  // Arrow-first: Cardputer may deliver arrows in scancode OR key.
+  // Keep vim-keys only as silent fallback (not in footer hints).
+  int nav = UIInput::navCodeWithVimFallback(ui_event);
+  switch (nav) {
     case MINIACID_LEFT:
       moveDrumCursor(-1);
       handled = true;
diff --git a/src/ui/pages/genre_page.cpp b/src/ui/pages/genre_page.cpp
index bd3aa63..55672b7 100644
--- a/src/ui/pages/genre_page.cpp
+++ b/src/ui/pages/genre_page.cpp
@@ -1,238 +1,194 @@
 #include "genre_page.h"
+#include "../ui_input.h"
 #include <cstdio>
-#include "../ui_colors.h"
+#include <cstdlib>
 
-GenrePage::GenrePage(IGfx& gfx, MiniAcid& mini_acid, AudioGuard& audio_guard)
-    : mini_acid_(mini_acid), audio_guard_(audio_guard) {
-}
+// Preset mappings: (genre, texture)
+// genre: 0=Acid, 1=Minimal, 2=Techno, 3=Electro, 4=Rave
+// texture: 0=Clean, 1=Dub, 2=Dark, 3=Hard
+static const uint8_t kPresetGenre[8]   = { 0, 2, 2, 3, 4, 0, 1, 2 };
+static const uint8_t kPresetTexture[8] = { 0, 1, 2, 3, 0, 1, 2, 3 };
 
-void GenrePage::draw(IGfx& gfx) {
-    const Rect& bounds = getBoundaries();
-    int x = bounds.x;
-    int y = bounds.y;
-    int w = bounds.w;
-    int h = bounds.h;
+const char* GenrePage::genreNames[5] = {
+    "ACID", "MINIMAL", "TECHNO", "ELECTRO", "RAVE"
+};
 
-    GenreManager& gm = mini_acid_.genreManager();
+const char* GenrePage::textureNames[4] = {
+    "CLEAN", "DUB", "DARK", "HARD"
+};
 
-    // Clear background
-    gfx.fillRect(x, y, w, h, COLOR_BLACK);
+const char* GenrePage::presetNames[8] = {
+    "303 ACID", "DUB TECHNO", "DARK TECHNO", 
+    "HARD ELECTRO", "RAVE", "ACID DUB",
+    "MINIMAL DARK", "HARD TECHNO"
+};
 
-    // Header: Current genre name
-    gfx.setTextColor(COLOR_WHITE);
-    gfx.drawText(x + 5, y + 3, "GENRE:");
-    gfx.setTextColor(COLOR_KNOB_1);
-    gfx.drawText(x + 55, y + 3, gm.getCurrentGenreName());
+GenrePage::GenrePage(IGfx& gfx, MiniAcid& mini_acid, AudioGuard& audio_guard)
+    : mini_acid_(mini_acid), audio_guard_(audio_guard) {
+    updateFromEngine();
+}
 
-    // === GENERATIVE AXIS (Left Side) ===
-    int leftX = x + 5;
-    int colY = y + 18;
+void GenrePage::draw(IGfx& gfx) {
+    // Header
+    char sceneStr[8];
+    snprintf(sceneStr, sizeof(sceneStr), "%02d", mini_acid_.currentScene() + 1);
     
-    gfx.setTextColor(COLOR_LABEL);
-    gfx.drawText(leftX, colY, "GENERATIVE");
+    char genreStr[32];
+    snprintf(genreStr, sizeof(genreStr), "%s/%s", 
+             genreNames[genreIndex_], textureNames[textureIndex_]);
     
-    const char* genNames[] = {"Acid", "Minimal", "Hypnotic", "Electro", "Rave"};
-    int currentGen = static_cast<int>(gm.generativeMode());
+    LayoutManager::drawHeader(gfx, sceneStr, mini_acid_.bpm(), 
+                             genreStr, mini_acid_.isRecording());
     
-    // Selection box
-    int boxY = colY + 10;
-    if (focusAxis_ == GENERATIVE) {
-        gfx.fillRect(leftX, boxY, 55, 14, COLOR_KNOB_1);
-        gfx.setTextColor(COLOR_BLACK);
-    } else {
-        gfx.drawRect(leftX, boxY, 55, 14, COLOR_KNOB_2);
-        gfx.setTextColor(COLOR_WHITE);
-    }
-    gfx.drawText(leftX + 4, boxY + 3, genNames[currentGen]);
+    // Content
+    LayoutManager::clearContent(gfx);
+    
+    // Левая колонка: жанры
+    int y0 = LayoutManager::lineY(0);
+    gfx.setTextColor(COLOR_WHITE);
+    gfx.drawText(Layout::COL_1, y0, "GENRE:");
     
-    // Mode list
-    int listY = boxY + 18;
     for (int i = 0; i < 5; i++) {
-        gfx.setTextColor((i == currentGen) ? COLOR_WHITE : COLOR_LABEL);
-        char buf[16];
-        snprintf(buf, sizeof(buf), "%d %s", i + 1, genNames[i]);
-        gfx.drawText(leftX, listY + i * 10, buf);
+        int y = LayoutManager::lineY(1 + i);
+        Widgets::drawListRow(gfx, Layout::COL_1, y, Layout::COL_WIDTH,
+                            genreNames[i], 
+                            (i == genreIndex_) && (focus_ == FocusArea::GENRE),
+                            i == 4); // Иконка у RAVE
     }
-
-    // === TEXTURE AXIS (Right Side) ===
-    int rightX = x + 115;
     
-    gfx.setTextColor(COLOR_LABEL);
-    gfx.drawText(rightX, colY, "TEXTURE");
+    // Правая колонка: текстуры
+    gfx.setTextColor(COLOR_WHITE);
+    gfx.drawText(Layout::COL_2, y0, "TEXTURE:");
     
-    const char* texNames[] = {"Clean", "Dub", "LoFi", "Industrial"};
-    int currentTex = static_cast<int>(gm.textureMode());
+    for (int i = 0; i < 4; i++) {
+        int y = LayoutManager::lineY(1 + i);
+        Widgets::drawListRow(gfx, Layout::COL_2, y, Layout::COL_WIDTH,
+                            textureNames[i],
+                            (i == textureIndex_) && (focus_ == FocusArea::TEXTURE));
+    }
     
-    // Selection box
-    if (focusAxis_ == TEXTURE) {
-        gfx.fillRect(rightX, boxY, 55, 14, COLOR_KNOB_2);
-        gfx.setTextColor(COLOR_BLACK);
-    } else {
-        gfx.drawRect(rightX, boxY, 55, 14, COLOR_KNOB_1);
-        gfx.setTextColor(COLOR_WHITE);
+    // Нижняя часть: пресеты (8 штук, сетка 2×4)
+    // ВАЖНО: было 2×8 → drawButtonGrid ожидал 16 labels → краш при чтении мусора
+    int yp = LayoutManager::lineY(4);
+    gfx.setTextColor(COLOR_WHITE);
+    gfx.drawText(Layout::COL_1, yp, "PRESETS:");
+    
+    const char* presetLabels[8];
+    for (int i = 0; i < 8; i++) {
+        presetLabels[i] = presetNames[i];
     }
-    gfx.drawText(rightX + 4, boxY + 3, texNames[currentTex]);
     
-    // Mode list
-    for (int i = 0; i < 4; i++) {
-        gfx.setTextColor((i == currentTex) ? COLOR_WHITE : COLOR_LABEL);
-        char buf[16];
-        snprintf(buf, sizeof(buf), "%d %s", i + 6, texNames[i]);
-        gfx.drawText(rightX, listY + i * 10, buf);
+    // Сетка 2 колонки × 4 ряда = 8 элементов
+    // cellW=58, cellH=10 чтобы точно влезло в CONTENT без наезда на footer
+    Widgets::drawButtonGrid(
+        gfx,
+        Layout::COL_1,
+        yp + Layout::LINE_HEIGHT,
+        58, 10,
+        2, 4,
+        presetLabels,
+        8,  // labelsCount - SAFE: prevents OOB reads
+        (focus_ == FocusArea::PRESETS) ? presetIndex_ : -1
+    );
+    // Footer - QWERTY friendly, ARROWS FIRST (no gamepad A/B)
+    const char* footerLeft;
+    const char* footerRight;
+    if (focus_ == FocusArea::GENRE || focus_ == FocusArea::TEXTURE) {
+        footerLeft = "[ARROWS] [TAB]NEXT [ENT]APPLY";
+        footerRight = "[0]RANDOM";
+    } else {
+        footerLeft = "[1-8] SELECT [ENT]APPLY";
+        footerRight = "";
     }
-
-    // === HINTS ===
-    int hintY = y + h - 20;
-    gfx.setTextColor(COLOR_LABEL);
-    gfx.drawText(x + 5, hintY, "[up/dn] axis [L/R] change [ENTER] regen");
+    
+    LayoutManager::drawFooter(gfx, footerLeft, footerRight);
 }
 
-bool GenrePage::handleEvent(UIEvent& ui_event) {
-    if (ui_event.event_type != MINIACID_KEY_DOWN) return false;
-
-    switch (ui_event.key) {
-        // Numbers 1-5: generative mode
-        case '1':
-            setGenerativeMode(GenerativeMode::Acid);
-            return true;
-        case '2':
-            setGenerativeMode(GenerativeMode::Outrun);
-            return true;
-        case '3':
-            setGenerativeMode(GenerativeMode::Darksynth);
-            return true;
-        case '4':
-            setGenerativeMode(GenerativeMode::Electro);
-            return true;
-        case '5':
-            setGenerativeMode(GenerativeMode::Rave);
-            return true;
-        
-        // Numbers 6-9: texture mode
-        case '6':
-            setTextureMode(TextureMode::Clean);
-            return true;
-        case '7':
-            setTextureMode(TextureMode::Dub);
-            return true;
-        case '8':
-            setTextureMode(TextureMode::LoFi);
-            return true;
-        case '9':
-            setTextureMode(TextureMode::Industrial);
-            return true;
-        
-        // Navigation between axes
-        case MINIACID_UP:
-        case MINIACID_DOWN:
-            focusAxis_ = (focusAxis_ == GENERATIVE) ? TEXTURE : GENERATIVE;
+bool GenrePage::handleEvent(UIEvent& e) {
+    if (e.event_type != MINIACID_KEY_DOWN) return false;
+    
+    // Helper lambdas for navigation
+    auto moveUp = [&]() {
+        if (focus_ == FocusArea::GENRE) genreIndex_ = (genreIndex_ - 1 + 5) % 5;
+        else if (focus_ == FocusArea::TEXTURE) textureIndex_ = (textureIndex_ - 1 + 4) % 4;
+        else if (focus_ == FocusArea::PRESETS) presetIndex_ = (presetIndex_ - 1 + 8) % 8;
+    };
+    auto moveDown = [&]() {
+        if (focus_ == FocusArea::GENRE) genreIndex_ = (genreIndex_ + 1) % 5;
+        else if (focus_ == FocusArea::TEXTURE) textureIndex_ = (textureIndex_ + 1) % 4;
+        else if (focus_ == FocusArea::PRESETS) presetIndex_ = (presetIndex_ + 1) % 8;
+    };
+    auto moveLeft = [&]() {
+        if (focus_ == FocusArea::TEXTURE) focus_ = FocusArea::GENRE;
+        else if (focus_ == FocusArea::PRESETS) focus_ = FocusArea::TEXTURE;
+    };
+    auto moveRight = [&]() {
+        if (focus_ == FocusArea::GENRE) focus_ = FocusArea::TEXTURE;
+        else if (focus_ == FocusArea::TEXTURE) focus_ = FocusArea::PRESETS;
+    };
+    
+    // 1) Check SCANCODE for arrow keys (primary navigation)
+    switch (UIInput::navCode(e)) {
+        case MINIACID_UP:    moveUp(); return true;
+        case MINIACID_DOWN:  moveDown(); return true;
+        case MINIACID_LEFT:  moveLeft(); return true;
+        case MINIACID_RIGHT: moveRight(); return true;
+        default: break;
+    }
+    
+    // 2) Check KEY for character keys (ijkl alias + others)
+    switch (e.key) {
+        case 'i': moveUp(); return true;      // vim alias
+        case 'k': moveDown(); return true;    // vim alias
+        case 'j': moveLeft(); return true;    // vim alias
+        case 'l': moveRight(); return true;   // vim alias
+            
+        case '\t': // TAB - cycle focus
+            if (focus_ == FocusArea::GENRE) focus_ = FocusArea::TEXTURE;
+            else if (focus_ == FocusArea::TEXTURE) focus_ = FocusArea::PRESETS;
+            else focus_ = FocusArea::GENRE;
             return true;
-        
-        // Cycle within focused axis
-        case MINIACID_LEFT:
-            if (focusAxis_ == GENERATIVE) {
-                cycleGenerative(-1);
-            } else {
-                cycleTexture(-1);
-            }
+            
+        case '1': case '2': case '3': case '4':
+        case '5': case '6': case '7': case '8':
+            focus_ = FocusArea::PRESETS;
+            presetIndex_ = (int)(e.key - '1');
+            if (presetIndex_ < 0 || presetIndex_ > 7) presetIndex_ = 0;
+            genreIndex_ = (int)kPresetGenre[presetIndex_];
+            textureIndex_ = (int)kPresetTexture[presetIndex_];
+            applyCurrent();
             return true;
-        
-        case MINIACID_RIGHT:
-            if (focusAxis_ == GENERATIVE) {
-                cycleGenerative(1);
-            } else {
-                cycleTexture(1);
-            }
+            
+        case '\n': case '\r': // ENTER
+            applyCurrent();
             return true;
-        
-        // Regenerate patterns with current genre
-        case '\n':
-        case '\r':
-            regenerate();
+            
+        case '0': // Random
+            genreIndex_ = rand() % 5;
+            textureIndex_ = rand() % 4;
+            applyCurrent();
             return true;
         
-        // Space to preview (start playback)
-        case ' ':
-            withAudioGuard([&](){
-                mini_acid_.regeneratePatternsWithGenre();
-                if (!mini_acid_.isPlaying()) {
-                    mini_acid_.start();
-                }
-            });
-            return true;
+        // Global keys - return false to let parent handle
+        case '[': case ']': case 'h': case 'b': case 'B':
+        case 'g': case 't': case 'm': case 's': case 'p':
+            return false;
     }
-
+    
     return false;
 }
 
-const std::string& GenrePage::getTitle() const {
-    return title_;
-}
 
-void GenrePage::setGenerativeMode(GenerativeMode mode) {
+void GenrePage::applyCurrent() {
     withAudioGuard([&](){
-        mini_acid_.genreManager().setGenerativeMode(mode);
-        
-        // 1. Enforce Genre Timbre BASE (overwrites base params)
-        mini_acid_.genreManager().applyGenreTimbre(mini_acid_);
-        
-        // 2. Reset bias tracking (new base established)
-        mini_acid_.genreManager().resetTextureBiasTracking();
-        
-        // 3. Re-apply current texture (as delta from new base)
-        mini_acid_.genreManager().applyTexture(mini_acid_);
-    });
-}
-
-void GenrePage::setTextureMode(TextureMode mode) {
-    withAudioGuard([&](){
-        mini_acid_.genreManager().setTextureMode(mode);
-        // Apply texture params (delta bias + FX)
-        mini_acid_.genreManager().applyTexture(mini_acid_);
-        // Texture affects stepMask, so regenerate
+        mini_acid_.genreManager().setGenerativeMode(static_cast<GenerativeMode>(genreIndex_));
+        mini_acid_.genreManager().setTextureMode(static_cast<TextureMode>(textureIndex_));
         mini_acid_.regeneratePatternsWithGenre();
-    });
-}
-
-void GenrePage::cycleGenerative(int dir) {
-    withAudioGuard([&](){
-        mini_acid_.genreManager().cycleGenerative(dir);
-        
-        // 1. Enforce Genre Timbre BASE
-        mini_acid_.genreManager().applyGenreTimbre(mini_acid_);
-        
-        // 2. Reset bias tracking
-        mini_acid_.genreManager().resetTextureBiasTracking();
         
-        // 3. Re-apply texture
-        mini_acid_.genreManager().applyTexture(mini_acid_);
-    });
-}
-
-void GenrePage::cycleTexture(int dir) {
-    withAudioGuard([&](){
-        mini_acid_.genreManager().cycleTexture(dir);
-        // Apply texture params (delta bias + FX)
-        mini_acid_.genreManager().applyTexture(mini_acid_);
-        // Texture affects stepMask
-        mini_acid_.regeneratePatternsWithGenre();
-    });
-}
-
-void GenrePage::applyGenrePreset(int presetIndex) {
-    if (presetIndex < 0 || presetIndex >= kGenrePresetCount) return;
-    
-    // Use high-level wrappers to ensure proper timbre/texture logic sequence
-    // 1. setGenerativeMode: Applies Base Timbre -> Resets Bias Tracking -> Applies Old Texture (Delta)
-    // 2. setTextureMode: Sets New Texture -> Applies New Texture (Delta) -> Regenerates
-    const GenrePreset& preset = kGenrePresets[presetIndex];
-    setGenerativeMode(preset.generative);
-    setTextureMode(preset.texture);
-}
-
-void GenrePage::regenerate() {
-    withAudioGuard([&](){
-        mini_acid_.regeneratePatternsWithGenre();
+        // Автостарт если не играет
+        if (!mini_acid_.isPlaying()) {
+            mini_acid_.start();
+        }
     });
 }
 
@@ -243,3 +199,8 @@ void GenrePage::withAudioGuard(const std::function<void()>& fn) {
         fn();
     }
 }
+
+void GenrePage::updateFromEngine() {
+    genreIndex_ = (int)mini_acid_.genreManager().generativeMode();
+    textureIndex_ = (int)mini_acid_.genreManager().textureMode();
+}
diff --git a/src/ui/pages/genre_page.h b/src/ui/pages/genre_page.h
index d16b44b..fb4d20f 100644
--- a/src/ui/pages/genre_page.h
+++ b/src/ui/pages/genre_page.h
@@ -2,30 +2,34 @@
 
 #include "../ui_core.h"
 #include "../../dsp/miniacid_engine.h"
+#include "../layout_manager.h"
+#include "../ui_widgets.h"
 
 class GenrePage : public IPage {
 public:
+    enum class FocusArea { GENRE, TEXTURE, PRESETS };
+    
     GenrePage(IGfx& gfx, MiniAcid& mini_acid, AudioGuard& audio_guard);
     
     void draw(IGfx& gfx) override;
     bool handleEvent(UIEvent& ui_event) override;
-    const std::string& getTitle() const override;
+    const std::string& getTitle() const override { return title_; }
     
 private:
     MiniAcid& mini_acid_;
     AudioGuard& audio_guard_;
-    
-    enum FocusAxis { GENERATIVE, TEXTURE };
-    FocusAxis focusAxis_ = GENERATIVE;
-    
     std::string title_ = "GENRE";
+    FocusArea focus_ = FocusArea::GENRE;
+    int genreIndex_ = 0;
+    int textureIndex_ = 0;
+    int presetIndex_ = 0;
     
-    void setGenerativeMode(GenerativeMode mode);
-    void setTextureMode(TextureMode mode);
-    void cycleGenerative(int dir);
-    void cycleTexture(int dir);
-    void applyGenrePreset(int presetIndex);
-    void regenerate();
+    // Данные
+    static const char* genreNames[5];
+    static const char* textureNames[4];
+    static const char* presetNames[8];
     
+    void applyCurrent();
     void withAudioGuard(const std::function<void()>& fn);
+    void updateFromEngine();
 };
diff --git a/src/ui/pages/pattern_edit_page.cpp b/src/ui/pages/pattern_edit_page.cpp
index 96da50c..a1e4fb0 100644
--- a/src/ui/pages/pattern_edit_page.cpp
+++ b/src/ui/pages/pattern_edit_page.cpp
@@ -3,6 +3,8 @@
 #include <cctype>
 #include <utility>
 
+#include "../ui_input.h"
+#include "../layout_manager.h"
 #include "../help_dialog_frames.h"
 #include "../components/bank_selection_bar.h"
 #include "../components/pattern_selection_bar.h"
@@ -289,8 +291,16 @@ bool PatternEditPage::handleEvent(UIEvent& ui_event) {
     }
   }
   if (ui_event.event_type != MINIACID_KEY_DOWN) return false;
+
+  // Let parent handle global navigation keys; do not steal them here.
+  if (UIInput::isGlobalNav(ui_event)) return false;
+
   bool handled = false;
-  switch (ui_event.scancode) {
+  
+  // Arrow-first: Cardputer may deliver arrows in scancode OR key.
+  // Keep vim-keys only as silent fallback (not in footer hints).
+  int nav = UIInput::navCodeWithVimFallback(ui_event);
+  switch (nav) {
     case MINIACID_LEFT:
       movePatternCursor(-1);
       handled = true;
@@ -312,6 +322,24 @@ bool PatternEditPage::handleEvent(UIEvent& ui_event) {
   }
   if (handled) return true;
 
+  // Handle TAB for voice toggle
+  if (UIInput::isTab(ui_event)) {
+      voice_index_ = (voice_index_ + 1) % 2; // Toggle 0 <-> 1
+      title_ = voice_index_ == 0 ? "303A PATTERNS" : "303B PATTERNS";
+      
+      // Refresh state for new voice
+      bank_index_ = mini_acid_.current303BankIndex(voice_index_);
+      bank_cursor_ = bank_index_;
+      pattern_row_cursor_ = mini_acid_.current303PatternIndex(voice_index_);
+      if (pattern_row_cursor_ < 0) pattern_row_cursor_ = 0;
+      
+      if (pattern_row_cursor_ < 0) pattern_row_cursor_ = 0;
+      
+      // showToast(voice_index_ == 0 ? "Voice A (Bass)" : "Voice B (Lead)", 1000);
+      return true;
+      return true;
+  }
+
   char key = ui_event.key;
   if (!key) return false;
 
@@ -441,6 +469,8 @@ void PatternEditPage::drawHelpFrame(IGfx& gfx, int frameIndex, Rect bounds) cons
   }
 }
 
+
+
 void PatternEditPage::draw(IGfx& gfx) {
   bank_index_ = mini_acid_.current303BankIndex(voice_index_);
   const Rect& bounds = getBoundaries();
@@ -533,4 +563,7 @@ void PatternEditPage::draw(IGfx& gfx) {
     int ty = note_box_y + cell_size / 2 - gfx.fontHeight() / 2;
     gfx.drawText(tx, ty, note_label);
   }
+
+  // v1.1 Pro Footer
+  LayoutManager::drawFooter(gfx, "[ARROWS]NAV [ENT]SEL [TAB]VOICE", "[-/+]NOTE [G]RANDOM [SHIFT+W]ACC");
 }
diff --git a/src/ui/pages/project_page.cpp b/src/ui/pages/project_page.cpp
index cb8b935..c3b0da8 100644
--- a/src/ui/pages/project_page.cpp
+++ b/src/ui/pages/project_page.cpp
@@ -5,6 +5,8 @@
 #include <cstdio>
 #include <cstdlib>
 
+#include "../layout_manager.h"
+#include "../screen_geometry.h"
 #include "../help_dialog_frames.h"
 
 namespace {
@@ -422,14 +424,20 @@ const std::string & ProjectPage::getTitle() const {
 }
 
 void ProjectPage::draw(IGfx& gfx) {
-  const Rect& bounds = getBoundaries();
-  int x = bounds.x;
-  int y = bounds.y;
-  int w = bounds.w;
-  int h = bounds.h;
-
-  int body_y = y + 3;
-  int body_h = h - 3;
+  // v1.1 Pro: Use LayoutManager for consistent rendering
+  char sceneNum[8];
+  snprintf(sceneNum, sizeof(sceneNum), "%02d", mini_acid_.currentScene() + 1);
+  LayoutManager::drawHeader(gfx, sceneNum, mini_acid_.bpm(), "PROJECT", false);
+  LayoutManager::clearContent(gfx);
+  
+  // Use Layout::CONTENT for proper positioning
+  int x = Layout::CONTENT.x + Layout::CONTENT_PAD_X;
+  int y = Layout::CONTENT.y + Layout::CONTENT_PAD_Y;
+  int w = Layout::CONTENT.w - 2 * Layout::CONTENT_PAD_X;
+  int h = Layout::CONTENT.h - 2 * Layout::CONTENT_PAD_Y;
+
+  int body_y = y;
+  int body_h = h;
   if (body_h <= 0) return;
 
   int line_h = gfx.fontHeight();
@@ -521,9 +529,8 @@ void ProjectPage::draw(IGfx& gfx) {
   gfx.setTextColor(COLOR_ACCENT);
   gfx.drawText(x, vol_y + vol_h + 4, "NOTE: RGB needs Screen BL=100%");
 
-  gfx.setTextColor(COLOR_LABEL);
-  gfx.drawText(x, h - line_h - 2, "Enter/Arrow Keys to navigate");
-  gfx.setTextColor(COLOR_WHITE);
+  // v1.1 Pro Footer
+  LayoutManager::drawFooter(gfx, "[ARROWS]NAV [ENT]SELECT", "[M]MODE");
 
   if (dialog_type_ == DialogType::None) return;
 
diff --git a/src/ui/pages/sampler_page.cpp b/src/ui/pages/sampler_page.cpp
index c171c6d..50d1a8a 100644
--- a/src/ui/pages/sampler_page.cpp
+++ b/src/ui/pages/sampler_page.cpp
@@ -101,7 +101,7 @@ void SamplerPage::initComponents() {
 void SamplerPage::draw(IGfx& gfx) {
   if (!initialized_) initComponents();
 
-  SamplerPad& p = mini_acid_.samplerTrack.pad(current_pad_);
+  SamplerPad& p = mini_acid_.samplerTrack->pad(current_pad_);
   
   char buf[64];
   pad_ctrl_->setValue(std::to_string(current_pad_ + 1));
@@ -128,7 +128,7 @@ void SamplerPage::draw(IGfx& gfx) {
 }
 
 void SamplerPage::adjustFocusedElement(int direction) {
-  SamplerPad& p = mini_acid_.samplerTrack.pad(current_pad_);
+  SamplerPad& p = mini_acid_.samplerTrack->pad(current_pad_);
   const auto& files = mini_acid_.sampleIndex.getFiles();
 
   audio_guard_([&]() {
@@ -168,7 +168,7 @@ void SamplerPage::adjustFocusedElement(int direction) {
 
 void SamplerPage::prelisten() {
     audio_guard_([&]() {
-        mini_acid_.samplerTrack.triggerPad(current_pad_, 1.0f, *mini_acid_.sampleStore);
+        mini_acid_.samplerTrack->triggerPad(current_pad_, 1.0f, *mini_acid_.sampleStore);
     });
 }
 
@@ -199,7 +199,7 @@ bool SamplerPage::handleEvent(UIEvent& ui_event) {
   if (found) {
     int padIdx = found - triggerKeys;
     audio_guard_([&]() {
-        mini_acid_.samplerTrack.triggerPad(padIdx, 1.0f, *mini_acid_.sampleStore);
+        mini_acid_.samplerTrack->triggerPad(padIdx, 1.0f, *mini_acid_.sampleStore);
     });
     return true;
   }
diff --git a/src/ui/pages/tape_page.cpp b/src/ui/pages/tape_page.cpp
index 8dc5ca0..c1c53f7 100644
--- a/src/ui/pages/tape_page.cpp
+++ b/src/ui/pages/tape_page.cpp
@@ -96,7 +96,7 @@ class TapePage::ModeComponent : public FocusableComponent {
     guard_([this](){
       TapeState& tape = synth_.sceneManager().currentScene().tape;
       tape.mode = nextTapeMode(tape.mode);
-      synth_.tapeLooper.setMode(tape.mode);
+      synth_.tapeLooper->setMode(tape.mode);
     });
   }
 
@@ -145,7 +145,7 @@ class TapePage::PresetComponent : public FocusableComponent {
       } else {
         loadTapePreset(tape.preset, tape.macro);
       }
-      synth_.tapeFX.applyMacro(tape.macro);
+      synth_.tapeFX->applyMacro(tape.macro);
     });
   }
 
@@ -174,7 +174,7 @@ void TapePage::initComponents() {
         case 3: macro.tone = val; break;
         case 4: macro.crush = val; break;
       }
-      mini_acid_.tapeFX.applyMacro(macro);
+      mini_acid_.tapeFX->applyMacro(macro);
     });
   };
 
@@ -241,9 +241,9 @@ void TapePage::draw(IGfx& gfx) {
   gfx.drawText(x + 28, y, tapeSpeedName(tape.speed));
   
   // Loop length
-  if (mini_acid_.tapeLooper.hasLoop()) {
+  if (mini_acid_.tapeLooper->hasLoop()) {
     char buf[16];
-    snprintf(buf, sizeof(buf), "%.1fs", mini_acid_.tapeLooper.loopLengthSeconds());
+    snprintf(buf, sizeof(buf), "%.1fs", mini_acid_.tapeLooper->loopLengthSeconds());
     gfx.setTextColor(COLOR_LABEL);
     gfx.drawText(x + 70, y, "LEN:");
     gfx.setTextColor(COLOR_WHITE);
@@ -316,32 +316,32 @@ bool TapePage::handleEvent(UIEvent& ui_event) {
       audio_guard_([this](){
         TapeState& tape = mini_acid_.sceneManager().currentScene().tape;
         tape.speed = 0; // 0.5x
-        mini_acid_.tapeLooper.setSpeed(tape.speed);
+        mini_acid_.tapeLooper->setSpeed(tape.speed);
       });
       return true;
     case '2':
       audio_guard_([this](){
         TapeState& tape = mini_acid_.sceneManager().currentScene().tape;
         tape.speed = 1; // 1.0x
-        mini_acid_.tapeLooper.setSpeed(tape.speed);
+        mini_acid_.tapeLooper->setSpeed(tape.speed);
       });
       return true;
     case '3':
       audio_guard_([this](){
         TapeState& tape = mini_acid_.sceneManager().currentScene().tape;
         tape.speed = 2; // 2.0x
-        mini_acid_.tapeLooper.setSpeed(tape.speed);
+        mini_acid_.tapeLooper->setSpeed(tape.speed);
       });
       return true;
     case '\n': // Enter = stutter (TODO: hold detection)
       audio_guard_([this](){
-        mini_acid_.tapeLooper.setStutter(true);
+        mini_acid_.tapeLooper->setStutter(true);
       });
       return true;
     case '\b': // Backspace/Del = eject
     case 0x7F:
       audio_guard_([this](){
-        mini_acid_.tapeLooper.eject();
+        mini_acid_.tapeLooper->eject();
         TapeState& tape = mini_acid_.sceneManager().currentScene().tape;
         tape.mode = TapeMode::Stop;
         tape.fxEnabled = false;
@@ -349,7 +349,7 @@ bool TapePage::handleEvent(UIEvent& ui_event) {
       return true;
     case ' ':
       audio_guard_([this](){
-        mini_acid_.tapeLooper.clear();
+        mini_acid_.tapeLooper->clear();
       });
       return true;
   }
diff --git a/src/ui/pages/tb303_params_page.cpp b/src/ui/pages/tb303_params_page.cpp
index 652afc5..35bd41a 100644
--- a/src/ui/pages/tb303_params_page.cpp
+++ b/src/ui/pages/tb303_params_page.cpp
@@ -1,11 +1,15 @@
 #include "tb303_params_page.h"
 
 #include <algorithm>
+#include <cctype>
 #include <cstdarg>
 #include <cstdio>
 #include <cmath>
 #include <functional>
 
+#include "../layout_manager.h"
+#include "../screen_geometry.h"
+#include "../ui_widgets.h"
 #include "../help_dialog_frames.h"
 
 namespace {
@@ -326,122 +330,44 @@ void Synth303ParamsPage::adjustFocusedElement(int direction) {
 }
 
 void Synth303ParamsPage::draw(IGfx& gfx) {
-  (void)gfx;
-  if (!initialized_) {
-    initComponents();
-  }
-
-  char buf[128];
-  auto print = [&](int px, int py, const char* fmt, ...) {
-    va_list ap;
-    va_start(ap, fmt);
-    vsnprintf(buf, sizeof(buf), fmt, ap);
-    va_end(ap);
-    gfx_.drawText(px, py, buf);
-  };
-
-  int center_y_for_knobs = dy() + height() / 2 - 13;
-
-  int x_margin = 4;  // Fixed: was -10 causing overflow!
-  int usable_w = width() - x_margin * 2;
-
-  int radius = 14;  // Reduced from 18 to fit better
-  int spacing = usable_w / 5;
+  // v1.1 Pro: Simple Widgets-based rendering
+  const char* title = voice_index_ == 0 ? "303A BASS" : "303B LEAD";
+  char sceneNum[8];
+  snprintf(sceneNum, sizeof(sceneNum), "%02d", mini_acid_.currentScene() + 1);
+  LayoutManager::drawHeader(gfx, sceneNum, mini_acid_.bpm(), title, false);
+  LayoutManager::clearContent(gfx);
   
-  int cx1 = dx() + x_margin + spacing * 1;
-  int cx2 = dx() + x_margin + spacing * 2;
-  int cx3 = dx() + x_margin + spacing * 3;
-  int cx4 = dx() + x_margin + spacing * 4;
-
-  int delta_y_for_controls = 35;
-  int delta_x_for_controls = -9;
-  int rowLeft = dx() + 6;
-  int labelValueGap = 2;
-  int controlGap = 8;
-
-  // oscillator type control
+  int x = Layout::CONTENT.x + Layout::CONTENT_PAD_X;
+  int w = Layout::CONTENT.w - 2 * Layout::CONTENT_PAD_X;
+  
+  // Get current parameters
+  const Parameter& pCut = mini_acid_.parameter303(TB303ParamId::Cutoff, voice_index_);
+  const Parameter& pRes = mini_acid_.parameter303(TB303ParamId::Resonance, voice_index_);
+  const Parameter& pEnv = mini_acid_.parameter303(TB303ParamId::EnvAmount, voice_index_);
+  const Parameter& pDec = mini_acid_.parameter303(TB303ParamId::EnvDecay, voice_index_);
   const Parameter& pOsc = mini_acid_.parameter303(TB303ParamId::Oscillator, voice_index_);
-  const Parameter& pFilter = mini_acid_.parameter303(TB303ParamId::FilterType, voice_index_);
-
+  
+  // Draw parameter rows using Widgets
+  int row = 0;
+  Widgets::drawBarRow(gfx, x, LayoutManager::lineY(row++), w, "CUTOFF", pCut.normalized(), true);
+  Widgets::drawBarRow(gfx, x, LayoutManager::lineY(row++), w, "RESO", pRes.normalized(), true);
+  Widgets::drawBarRow(gfx, x, LayoutManager::lineY(row++), w, "ENV", pEnv.normalized(), true);
+  Widgets::drawBarRow(gfx, x, LayoutManager::lineY(row++), w, "DECAY", pDec.normalized(), true);
+  
+  // Oscillator type and toggles
   const char* oscLabel = pOsc.optionLabel();
-  if (!oscLabel) oscLabel = "";
-  int oscLabelX = rowLeft;
-  int oscSwitchesY = dy() + height() - 13;
-  int oscLabelW = textWidth(gfx_, "OSC:");
-  int oscValueW = textWidth(gfx_, oscLabel);
-  int oscValueMaxW = textWidth(gfx_, "super");
-  int oscValueX = oscLabelX + oscLabelW + labelValueGap;
-  if (osc_control_) {
-    osc_control_->setValue(oscLabel);
-    int oscFocusW = oscLabelW + labelValueGap + oscValueW;
-    int oscFocusH = gfx_.fontHeight();
-    osc_control_->setBoundaries(Rect(oscLabelX, oscSwitchesY,
-                                     oscFocusW, oscFocusH));
-  }
-
-  // filter type control
-  const char* filterLabel = pFilter.optionLabel();
-  if (!filterLabel) filterLabel = "";
-  int filterLabelX = oscValueX + oscValueMaxW + controlGap;
-  int filterLabelW = textWidth(gfx_, "FLT:");
-  int filterValueW = textWidth(gfx_, filterLabel);
-  int filterValueMaxW = textWidth(gfx_, "lp-1");
-  int filterValueX = filterLabelX + filterLabelW + labelValueGap;
-  if (filter_control_) {
-    filter_control_->setValue(filterLabel);
-    int filterFocusW = filterLabelW + labelValueGap + filterValueW;
-    int filterFocusH = gfx_.fontHeight();
-    filter_control_->setBoundaries(Rect(filterLabelX, oscSwitchesY,
-                                        filterFocusW, filterFocusH));
-  }
-
-  // distortion toggle control
-  bool distortionEnabled = mini_acid_.is303DistortionEnabled(voice_index_);
-  int distLabelX = filterValueX + filterValueMaxW + controlGap;
-  int distLabelW = textWidth(gfx_, "DST:");
-  int distLabelMaxW = textWidth(gfx_, "off");
-  const char* distortionValue = distortionEnabled ? "on" : "off";
-  int delayLabelX = distLabelX + distLabelW + labelValueGap + distLabelMaxW + controlGap;
-  int delayLabelW = textWidth(gfx_, "DLY:");
-  if (distortion_control_) {
-    distortion_control_->setValue(distortionValue);
-    int distortionValueW = textWidth(gfx_, distortionValue);
-    int distortionFocusW = distLabelW + labelValueGap + distortionValueW;
-    int distortionFocusH = gfx_.fontHeight();
-    distortion_control_->setBoundaries(Rect(distLabelX, oscSwitchesY,
-                                            distortionFocusW, distortionFocusH));
-  }
-
-  // delay toggle control
-  bool delayEnabled = mini_acid_.is303DelayEnabled(voice_index_);
-  const char* delayValue = delayEnabled ? "on" : "off";
-  // int delayLabelW = textWidth(gfx_, "DLY:");
-  // int delayValueMaxW = textWidth(gfx_, "off");
-  if (delay_control_) {
-    delay_control_->setValue(delayValue);
-    int delayValueW = textWidth(gfx_, delayValue);
-    int delayFocusW = delayLabelW + labelValueGap + delayValueW;
-    int delayFocusH = gfx_.fontHeight();
-    delay_control_->setBoundaries(Rect(delayLabelX, oscSwitchesY,
-                                       delayFocusW, delayFocusH));
-  }
-
+  Widgets::drawToggleRow(gfx, x, LayoutManager::lineY(row++), w, "OSC", true, oscLabel ? oscLabel : "SAW");
+  Widgets::drawToggleRow(gfx, x, LayoutManager::lineY(row++), w, "DIST", mini_acid_.is303DistortionEnabled(voice_index_), nullptr);
+  Widgets::drawToggleRow(gfx, x, LayoutManager::lineY(row++), w, "DELAY", mini_acid_.is303DelayEnabled(voice_index_), nullptr);
+  
   // Mode badge
   GrooveboxMode mode = mini_acid_.grooveboxMode();
-  uint16_t modeColor = (mode == GrooveboxMode::Acid) ? kAcidConfig.accentColor : kMinimalConfig.accentColor;
   const char* modeName = (mode == GrooveboxMode::Acid) ? "ACID" : "MINIMAL";
-  int badgeW = textWidth(gfx_, modeName) + 6;
-  int badgeX = dx() + width() - badgeW - 2;
-  gfx_.fillRect(badgeX, dy(), badgeW, 10, (IGfxColor)modeColor);
-  gfx_.setTextColor(COLOR_BLACK);
-  gfx_.drawText(badgeX + 3, dy() + 2, modeName);
-
-  // Hint (simplified - removed presets section for space)
-  gfx_.setTextColor(COLOR_LABEL);
-  gfx_.drawText(dx() + 6, dy() + height() - 10, "[M] Mode  [1-4] Preset  [G] Random");
-
-  // finally draw all child components
-  Container::draw(gfx_);
+  gfx.setTextColor(COLOR_LABEL);
+  gfx.drawText(x + w - 50, LayoutManager::lineY(0), modeName);
+
+  // v1.1 Pro Footer
+  LayoutManager::drawFooter(gfx, "[ARROWS]SEL [-/+]ADJ", "[M]MODE [1-4]PRESET");
 }
 
 void Synth303ParamsPage::withAudioGuard(const std::function<void()>& fn) {
diff --git a/src/ui/ui_colors.h b/src/ui/ui_colors.h
index 0b14d5b..168bcdc 100644
--- a/src/ui/ui_colors.h
+++ b/src/ui/ui_colors.h
@@ -22,6 +22,8 @@ inline constexpr IGfxColor COLOR_DRUM_HIGH_TOM = IGfxColor(0x9AE3FF);
 inline constexpr IGfxColor COLOR_DRUM_RIM = IGfxColor(0xFF7D8D);
 inline constexpr IGfxColor COLOR_DRUM_CLAP = IGfxColor(0xFFC1E0);
 inline constexpr IGfxColor COLOR_LABEL = IGfxColor(0xCCCCCC);
+inline constexpr IGfxColor COLOR_DARK_GRAY = IGfxColor(0x282828);
+inline constexpr IGfxColor COLOR_RED = IGfxColor::Red();
 inline constexpr IGfxColor COLOR_MUTE_BACKGROUND = IGfxColor::Purple();
 inline constexpr IGfxColor COLOR_GRAY_DARKER = IGfxColor(0x202020);
 inline constexpr IGfxColor COLOR_KNOB_1 = IGfxColor::Orange();
